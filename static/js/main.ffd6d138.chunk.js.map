{"version":3,"sources":["hooks/useGrid.js","components/Cell.js","utility/GraphAlgorithms/BFS.js","utility/GraphAlgorithms/DFS.js","utility/helper.js","utility/GraphAlgorithms/Dijkstra.js","utility/MazeGenerators/RecursiveDivision.js","components/Board.js","utility/MazeGenerators/Random.js","App.js","index.js"],"names":["useGrid","numRows","numCols","startRow","startCol","initialRow","initialCol","targetRow","Math","floor","targetCol","useState","arr","row","col","createGrid","grid","setGrid","initialCoords","setInitialCoords","targetCoords","setTargetCoords","setCoord","val","newGrid","resetGrid","cell","document","getElementById","classList","contains","React","memo","isMouseDown","isMovingKeyItem","setIsMovingKeyItem","animationComplete","predecessors","drawShortestPath","classes","push","className","join","id","onMouseDown","onMouseEnter","add","onMouseLeave","remove","onMouseUp","draggable","prevState","nextState","bfs","a","queue","distance","predecesor","count","neighbors","generateAdjList","animations","length","item","shift","adjacent","i","dfs","stack","pop","getNeighbors","neighborsGrid","cellNotInGraph","list","rowNum","colNum","generateNeighborsGrid","clone","board","slice","dijkstra","recursiveDivision","drawContourWalls","width","height","prohibitedCells","divide","chooseOrientation","orientation","prohibited","horizontal","whereCol","ceil","random","whereRow","passCol","passRow","drawWall","newwidth","newheight","newwidth2","newheight2","isProhibitedCoord","isBorder","updateProhibitedCells","j","START_ROW","ROWS_INIT","START_COL","colStart","rowStart","nextObj","currentCol","currentRow","Board","setIsMouseDown","setAnimationComplete","setPredecessors","Grid","map","key","doSearch","type","intervalId","setInterval","clearInterval","clear","style","margin","Button","onClick","randomMaze","gridTemplateRows","gridTemplateColumns","App","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.ffd6d138.chunk.js","sourcesContent":["import { useState } from \"react\";\n\nconst createGrid = (numRows, numCols, startRow, startCol) => {\n  let arr = [];\n  for (let row = 0; row < numRows; row++) {\n    arr[row] = [];\n    for (let col = 0; col < numCols; col++) {\n      arr[row][col] = \" \";\n    }\n  }\n  arr[startRow][startCol] = \"s\";\n  arr[Math.floor(numRows / 2)][Math.floor((numCols * 2) / 3)] = \"t\";\n  return arr;\n};\n\nconst useGrid = (numRows, numCols, startRow, startCol) => {\n  let initialRow = startRow;\n  let initialCol = startCol;\n  let targetRow = Math.floor(numRows / 2);\n  let targetCol = Math.floor((numCols * 2) / 3);\n\n  const [grid, setGrid] = useState(\n    createGrid(numRows, numCols, initialRow, initialCol)\n  );\n  const [initialCoords, setInitialCoords] = useState({\n    startRow,\n    startCol,\n  });\n  const [targetCoords, setTargetCoords] = useState({\n    targetRow,\n    targetCol,\n  });\n\n  const setCoord = (row, col, val) => {\n    let newGrid = [...grid];\n    if (val === \"s\") {\n      setInitialCoords({ startRow: row, startCol: col });\n    }\n    if (val === \"t\") {\n      setTargetCoords({ targetRow: row, targetCol: col });\n    }\n    newGrid[row][col] = val;\n    setGrid(newGrid);\n  };\n\n  const resetGrid = (numRows, numCols) => {\n    for (let row = 0; row < numRows; row++) {\n      for (let col = 0; col < numCols; col++) {\n        const cell = document.getElementById(`${row} ${col}`);\n        if(!cell.classList.contains(\"Target\") && !cell.classList.contains(\"Filled\")){\n          cell.classList = [\"Cell\"]\n        }\n       \n      }\n    }\n  };\n\n  return { grid, setGrid, setCoord, resetGrid, initialCoords, targetCoords };\n};\n\nexport default useGrid;\n","import React from \"react\";\nimport \"./Cell.css\";\n\nconst Cell = ({\n  val,\n  row,\n  col,\n  isMouseDown,\n  isMovingKeyItem,\n  setIsMovingKeyItem,\n  setCoord,\n  animationComplete,\n  predecessors,\n  drawShortestPath,\n}) => {\n  let classes = [\"Cell\"];\n  val === \"s\" && classes.push(\"Filled\");\n  val === \"t\" && classes.push(\"Target\");\n\n  const onMoveHandler = () => {\n    const cell = document.getElementById(`${row} ${col}`);\n    if (isMouseDown && !isMovingKeyItem[0]) {\n      cell.classList.add(\"Wall\");\n    }\n    if (isMovingKeyItem[0] && !animationComplete) {\n      if (isMovingKeyItem[1] === \"t\") {\n        cell.classList.add(\"Target\");\n      } else {\n        cell.classList.add(\"Filled\");\n      }\n    }\n    if (isMovingKeyItem[0] && animationComplete) {\n      drawShortestPath(row, col, predecessors, 0, 0);\n    }\n  };\n\n  const onLeaveHandler = () => {\n    const cell = document.getElementById(`${row} ${col}`);\n    if (isMouseDown && isMovingKeyItem[0]) {\n      if (isMovingKeyItem[1] === \"t\") {\n        cell.classList.remove(\"Target\");\n      } else {\n        cell.classList.remove(\"Filled\");\n      }\n    }\n  };\n\n  const onClickHandler = () => {\n    if (val === \"t\" || val === \"s\") {\n      setIsMovingKeyItem([true, val]);\n    }\n  };\n\n  const onMouseUpHandler = () => {\n    if (isMovingKeyItem[1]) {\n      // Set coord and set IsNotmoving key item\n      setCoord(row, col, isMovingKeyItem[1]);\n      setIsMovingKeyItem(false);\n    }\n  };\n\n  return (\n    <div\n      className={classes.join(\" \")}\n      id={`${row} ${col}`}\n      onMouseDown={onClickHandler}\n      onMouseEnter={onMoveHandler}\n      onMouseLeave={onLeaveHandler}\n      onMouseUp={onMouseUpHandler}\n      draggable={false}\n    ></div>\n  );\n};\n\nconst compare = (prevState, nextState) => {\n  return (\n    prevState.val === nextState.val &&\n    prevState.isMouseDown === nextState.isMouseDown\n  );\n};\n\nexport default React.memo(Cell, compare);\n","import { generateAdjList } from \"../index\";\n\n// BFS\n// 1. Set all nodes distance and predecessor equal to null EXCEPT the source\n// which we will set the distance to 0\n// 2. Add the source to the queue\n// 3. While the Queue is not Empty\n// 4. Get the next Item in the queue\n// 5. Loop thru all its neighbors if we have not isited the node set its distance and predecesor\n// and add it to the queue\n\nexport const bfs = async (grid, startRow, startCol) => {\n  const queue = [];\n  queue.push({\n    row: startRow,\n    col: startCol,\n    distance: 0,\n    predecesor: {\n      row: startRow,\n      col: startCol,\n    },\n  });\n  let count = 1;\n  const neighbors = generateAdjList(grid);\n  const animations = [];\n  const predecessors = [...grid];\n\n  while (queue.length !== 0) {\n    let item = queue.shift();\n    const adjacent = neighbors[item.row][item.col];\n    for (let i = 0; i < adjacent.length; i++) {\n      if (adjacent[i].distance === null) {\n        animations.push({ row: adjacent[i].row, col: adjacent[i].col });\n        adjacent[i].distance = count;\n        adjacent[i].predecesor = { row: item.row, col: item.col };\n        predecessors[adjacent[i].row][adjacent[i].col] = ({ row: item.row, col: item.col });\n        queue.push(adjacent[i]);\n      }\n    }\n    count++;\n  }\n  return { animations, predecessors };\n};\n","import { generateAdjList } from \"../index\";\n// DFS\n// 1. Set all nodes distance and predecessor equal to null EXCEPT the source\n// which we will set the distance to 0\n// 2. Add the source to the stack\n// 3. While the stack is not Empty\n// 4. Get the next Item in the stack\n// 5. Loop thru all its neighbors if we have not isited the node set its distance and predecesor\n// and add it to the stack\n\nexport const dfs = async (grid, startRow, startCol) => {\n  const stack = [];\n  stack.push({\n    row: startRow,\n    col: startCol,\n    distance: 0,\n    predecesor: {\n      row: startRow,\n      col: startCol,\n    },\n  });\n  let count = 1;\n  const neighbors = generateAdjList(grid);\n  const animations = [];\n  const predecessors = [...grid];\n\n  while (stack.length !== 0) {\n    let item = stack.pop();\n    const adjacent = neighbors[item.row][item.col];\n    for (let i = 0; i < adjacent.length; i++) {\n      if (adjacent[i].distance === null) {\n        animations.push({ row: adjacent[i].row, col: adjacent[i].col });\n        adjacent[i].distance = count;\n        adjacent[i].predecesor = { row: item.row, col: item.col };\n        predecessors[adjacent[i].row][adjacent[i].col] = {\n          row: item.row,\n          col: item.col,\n        };\n        stack.push(adjacent[i]);\n      }\n    }\n    count++;\n  }\n  return { animations, predecessors };\n};\n","const generateNeighborsGrid = (rowNum, colNum) => {\n  let arr = [];\n  for (let row = 0; row < rowNum; row++) {\n    arr[row] = [];\n    for (let col = 0; col < colNum; col++) {\n      arr[row][col] = {\n        row,\n        col,\n        distance: null,\n        predecesor: null,\n      };\n    }\n  }\n  return arr;\n};\n\nconst getNeighbors = (grid, row, col, neighborsGrid) => {\n  const cellNotInGraph = (row, col) => {\n    const cellClasses = document.getElementById(`${row} ${col}`).classList;\n    return cellClasses.contains(\"Wall\") \n  };\n  if (cellNotInGraph(row, col)) return [];\n  let neighbors = [];\n\n  if (row > 0 && !cellNotInGraph(row - 1, col)) {\n    // N\n    neighbors.push(neighborsGrid[row - 1][col]);\n  }\n  if (col > 0 && !cellNotInGraph(row, col - 1)) {\n    // W\n    neighbors.push(neighborsGrid[row][col - 1]);\n  }\n  if (row < grid.length - 1 && !cellNotInGraph(row + 1, col)) {\n    // S\n    neighbors.push(neighborsGrid[row + 1][col]);\n  }\n  if (col < grid[row].length - 1 && !cellNotInGraph(row, col + 1)) {\n    // E\n    neighbors.push(neighborsGrid[row][col + 1]);\n  }\n\n  return neighbors;\n};\n\nexport const generateAdjList = (grid) => {\n  let list = [];\n  let neighborsGrid = generateNeighborsGrid(grid.length, grid[0].length);\n  for (let row = 0; row < grid.length; row++) {\n    list[row] = [];\n    for (let col = 0; col < grid[row].length; col++) {\n      list[row][col] = getNeighbors(grid, row, col, neighborsGrid);\n    }\n  }\n  return list;\n};\n\nexport const clone = (board) => {\n  const clone = [];\n  for (var i = 0; i < board.length; i++)\n    clone[i] = board[i].slice();\n  return clone;\n}\n","import { generateAdjList } from \"../index\";\n\n// Dijkstra's\n// 1. Create Shortest Path Tree (SPT)\n// 2. Assign distance value to all vertices in the input graph: Inifinity if not the source else zero.\n// 3. While SPT does not include all vertices\n//  a) Pick vertex not in SPT that has minimum distance value\n//  b) Include the vertex to SPT\n//  c) Update distance value of all adjacent vertices of u\n\nexport const dijkstra = async (grid, startRow, startCol) => {\n  const queue = [];\n  queue.push({\n    row: startRow,\n    col: startCol,\n    distance: 0,\n    predecesor: {\n      row: startRow,\n      col: startCol,\n    },\n  });\n  let count = 1;\n  const neighbors = generateAdjList(grid);\n  const animations = [];\n  const predecessors = [...grid];\n\n  while (queue.length !== 0) {\n    let item = queue.shift();\n    const adjacent = neighbors[item.row][item.col];\n    for (let i = 0; i < adjacent.length; i++) {\n      if (adjacent[i].distance === null) {\n        animations.push({ row: adjacent[i].row, col: adjacent[i].col });\n        // Since this is an unweightes graph, no point in comparing the distances\n        adjacent[i].distance = count;\n        adjacent[i].predecesor = { row: item.row, col: item.col };\n        predecessors[adjacent[i].row][adjacent[i].col] = ({ row: item.row, col: item.col });\n        queue.push(adjacent[i]);\n      }\n    }\n    count++;\n  }\n  return { animations, predecessors };\n};\n","const HORIZONTAL = \"horizontal\";\nconst VERTICAL = \"vertical\";\n\nexport const recursiveDivision = async (grid) => {\n  drawContourWalls(grid);\n  const width = grid[0].length - 2; // Subtract 2 since we drew a contour\n  const height = grid.length - 2;\n  let prohibitedCells = [];\n  divide(\n    1,\n    1,\n    width,\n    height,\n    chooseOrientation(width, height),\n    prohibitedCells\n  );\n  // console.log(prohibitedCells);\n  // for (let i = 0; i < prohibitedCells.length; i++) {\n  //   const cell = document.getElementById(\n  //     `${prohibitedCells[i][0]} ${prohibitedCells[i][1]}`\n  //   );\n  //   if (cell) {\n  //     cell.classList.add(\"Filled\");\n  //   }\n  // }\n  // for (let i = 0; i < grid.length; i++) {\n  //   for (let j = 0; j < grid[i].length; j++) {\n  //     if (isProhibitedCoord(i, j, prohibitedCells)) {\n  //       console.log(i, j);\n  //     }\n  //   }\n  // }\n};\n\nconst divide = (col, row, width, height, orientation, prohibited) => {\n  //   console.log(\"divide with starting coords\", row, col);\n  //   console.log(\"divide with width and height\", width, height);\n  if (width <= 2 || height <= 2 ) return;\n\n  const horizontal = orientation === HORIZONTAL;\n\n  // Where will the wall be drawn from?\n  let whereCol =\n    col + (horizontal ? 0 : Math.ceil(Math.random() * (width - 2))); // Rand number between the col and width\n\n  let whereRow =\n    row + (horizontal ? Math.ceil(Math.random() * (height - 2)) : 0); // Rand number between the row and height\n\n  // Where will the passage through the wall exist?\n  const passCol =\n    whereCol + (horizontal ? Math.ceil(Math.random() * (width - 1)) : 0); // Rand number between the col and width\n  const passRow =\n    whereRow + (horizontal ? 0 : Math.ceil(Math.random() * (height - 1))); // Rand number between the row and height\n\n  // How long will the wall be?\n  const length = horizontal ? width : height;\n\n  // Draw the walls\n  drawWall(\n    whereRow,\n    whereCol,\n    passRow,\n    passCol,\n    horizontal,\n    length,\n    prohibited\n  );\n\n  let newCol = row;\n  let newRow = col;\n\n  let newwidth = horizontal ? width : whereCol - col;\n  let newheight = horizontal ? whereRow - row : height;\n  divide(\n    newCol,\n    newRow,\n    newwidth,\n    newheight,\n    chooseOrientation(newwidth, newheight),\n    prohibited\n  );\n\n  let newCol2 = horizontal ? col : whereCol + 1;\n  let newRow2 = horizontal ? whereRow + 1 : row;\n\n  let newwidth2 = horizontal ? width : col + width - whereCol - 1;\n  let newheight2 = horizontal ? row + height - whereRow - 1 : height;\n  // console.log(\n  //   \"divide to be called with col row width height\",\n  //   newCol,\n  //   newRow,\n  //   newwidth,\n  //   newheight\n  // );\n  divide(\n    newCol2,\n    newRow2,\n    newwidth2,\n    newheight2,\n    chooseOrientation(newwidth2, newheight2),\n    prohibited\n  );\n};\n\nconst drawWall = (\n  startRow,\n  startCol,\n  passRow,\n  passCol,\n  horizontal,\n  length,\n  prohibited\n) => {\n  // console.log(\"drawing with coords and length\", startRow, startCol, length);\n  for (let i = 0; i < length; i++) {\n    const row = startRow + (horizontal ? 0 : i);\n    const col = startCol + (horizontal ? i : 0);\n\n    const cell = document.getElementById(`${row} ${col}`);\n\n    if (\n      cell &&\n      !cell.classList.contains(\"Target\") &&\n      !cell.classList.contains(\"Filled\") &&\n      !isProhibitedCoord(row, col, prohibited)\n    ) {\n      cell.classList.add(\"Wall\");\n    }\n  }\n\n  const cell = document.getElementById(`${passRow} ${passCol}`);\n  if (cell && !isBorder(passRow, passCol)) {\n    // console.log(\n    //   isProhibitedCoord(passRow, passCol, prohibited),\n    //   passRow,\n    //   passCol\n    // );\n    cell.classList.remove(\"Wall\");\n  }\n  updateProhibitedCells(passRow, passCol, horizontal, prohibited);\n};\n\nconst chooseOrientation = (width, height) => {\n  if (width < height) {\n    return HORIZONTAL;\n  }\n  return VERTICAL;\n};\n\nconst drawContourWalls = (grid) => {\n  for (let i = 0; i < grid.length; i++) {\n    let classes = document.getElementById(`${i} ${0}`).classList;\n    classes.add(\"Wall\");\n    classes = document.getElementById(`${i} ${grid[i].length - 1}`).classList;\n    classes.add(\"Wall\");\n  }\n\n  for (let j = 0; j < grid[0].length; j++) {\n    let classes = document.getElementById(`${0} ${j}`).classList;\n    classes.add(\"Wall\");\n    classes = document.getElementById(`${grid.length - 1} ${j}`).classList;\n    classes.add(\"Wall\");\n  }\n};\n\nconst updateProhibitedCells = (row, col, horizontal, prohibited) => {\n  // console.log(\"updateProhibited passCoords\", row, col);\n  if (!horizontal) {\n    prohibited.push([row, col + 1]);\n    prohibited.push([row, col - 1]);\n  } else {\n    prohibited.push([row + 1, col]);\n    prohibited.push([row - 1, col]);\n  }\n};\n\nconst isProhibitedCoord = (row, col, prohibited) => {\n  for (let i = 0; i < prohibited.length; i++) {\n    if (prohibited[i][0] === row && prohibited[i][1] === col) return true;\n  }\n  return false;\n};\n\nconst isBorder = (row, col) => {\n  return row === 0 || row === 19 || col === 0 || col === 49;\n}\n","import React, { useState, Fragment } from \"react\";\nimport useGrid from \"../hooks/useGrid\";\nimport Cell from \"./Cell\";\nimport Button from \"@material-ui/core/Button\";\nimport {\n  bfs,\n  dfs,\n  clone,\n  dijkstra,\n  randomMaze,\n  recursiveDivision,\n} from \"../utility/index\";\nimport \"./Board.css\";\n\nconst ROWS_INIT = 20;\nconst COLS_INIT = 50;\nconst START_ROW = Math.floor(ROWS_INIT / 2);\nconst START_COL = Math.floor(COLS_INIT / 3);\n\nconst drawShortestPath = (row, col, predecessors, colStart, rowStart) => {\n  let nextObj = predecessors[row][col];\n  let currentCol = nextObj.col;\n  let currentRow = nextObj.row;\n  for (let row = 0; row < predecessors.length; row++) {\n    for (let col = 0; col < predecessors[row].length; col++) {\n      const cell = document.getElementById(`${row} ${col}`);\n\n      if (cell) {\n        const classes = cell.classList;\n        if (classes.contains(\"ShortestPath\")) {\n          classes.remove(\"ShortestPath\");\n          // classes.add(\"FinalSearched\");\n        }\n      }\n    }\n  }\n  while (currentCol !== colStart || currentRow !== rowStart) {\n    const cell = document.getElementById(`${currentRow} ${currentCol}`);\n    if (cell) {\n      const classes = cell.classList;\n      classes.remove(\"Searched\");\n      classes.add(\"ShortestPath\");\n\n      const nextObj = predecessors[currentRow][currentCol];\n      currentCol = nextObj.col;\n      currentRow = nextObj.row;\n    } else {\n      break;\n    }\n  }\n};\n\nconst Board = () => {\n  const { grid, setCoord, resetGrid, initialCoords, targetCoords } = useGrid(\n    ROWS_INIT,\n    COLS_INIT,\n    START_ROW,\n    START_COL\n  );\n\n  const [isMouseDown, setIsMouseDown] = useState(false);\n  const [isMovingKeyItem, setIsMovingKeyItem] = useState([false, null]);\n  const [animationComplete, setAnimationComplete] = useState(false);\n  const [predecessors, setPredecessors] = useState(null);\n\n  let Grid = grid.map((row, rowNum) => {\n    return row.map((val, colNum) => {\n      return (\n        <Cell\n          key={[rowNum, colNum]}\n          val={val}\n          row={rowNum}\n          col={colNum}\n          isMouseDown={isMouseDown}\n          isMovingKeyItem={isMovingKeyItem}\n          setIsMovingKeyItem={setIsMovingKeyItem}\n          setCoord={setCoord}\n          animationComplete={animationComplete}\n          predecessors={predecessors}\n          drawShortestPath={() =>\n            drawShortestPath(\n              rowNum,\n              colNum,\n              predecessors,\n              initialCoords.startCol,\n              initialCoords.startRow\n            )\n          }\n        />\n      );\n    });\n  });\n\n  const doSearch = async (type) => {\n    const rowStart = initialCoords.startRow;\n    const colStart = initialCoords.startCol;\n\n    const { animations, predecessors } = await type(\n      clone(grid),\n      rowStart,\n      colStart\n    );\n\n    setPredecessors(predecessors);\n\n    let count = 0;\n\n    const intervalId = setInterval(() => {\n      let row = animations[count].row;\n      let col = animations[count].col;\n      const cell = document.getElementById(`${row} ${col}`);\n\n      if (targetCoords.targetRow === row && targetCoords.targetCol === col) {\n        drawShortestPath(row, col, predecessors, colStart, rowStart);\n      } else {\n        !cell.classList.contains(\"Filled\") &&\n          !cell.classList.contains(\"Target\") &&\n          cell.classList.add(\"Searched\");\n      }\n\n      count++;\n\n      if (count >= animations.length) {\n        setAnimationComplete(true);\n        clearInterval(intervalId);\n      }\n    }, 3);\n  };\n\n  const clear = () => {\n    setAnimationComplete(false);\n    resetGrid(ROWS_INIT, COLS_INIT, START_ROW, START_COL);\n  };\n\n  const doRandomMaze = () => {\n    clear();\n    randomMaze(grid);\n  };\n\n  const doRecursiveDivision = () => {\n    clear();\n    recursiveDivision(grid);\n  };\n\n  return (\n    <Fragment>\n      <div style={{ margin: \"auto\" }}>\n        <Button onClick={() => doSearch(dfs)}>Do DFS</Button>\n        <Button onClick={() => doSearch(bfs)}>Do BFS</Button>\n        <Button onClick={() => doSearch(dijkstra)}>Dijkstra</Button>\n        <Button onClick={doRandomMaze}>Random Maze</Button>\n        <Button onClick={doRecursiveDivision}>Recursive Division</Button>\n        <Button onClick={clear}>Clear</Button>\n      </div>\n      <div\n        onMouseDown={() => {\n          setIsMouseDown(true);\n        }}\n        onMouseUp={() => {\n          setIsMouseDown(false);\n        }}\n        className=\"Board\"\n        style={{\n          gridTemplateRows: `repeat(${ROWS_INIT}, 1fr)`,\n          gridTemplateColumns: `repeat(${COLS_INIT}, 1fr)`,\n        }}\n      >\n        {Grid}\n      </div>\n    </Fragment>\n  );\n};\n\nexport default Board;\n","export const randomMaze = (board) => {\n  for (let row = 0; row < board.length; row++) {\n    for (let col = 0; col < board[row].length; col++) {\n      if (board[row][col] === \" \") {\n        if (Math.random() <= 0.3) {\n          const classes = document.getElementById(`${row} ${col}`).classList;\n          classes.add(\"Wall\");\n        }\n      }\n    }\n  }\n};\n","import React from 'react';\nimport './App.css';\nimport Board from \"./components/Board\"\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <h1 style={{margin: \"auto\"}}>Graphing Algorithm Visualization</h1>\n      <Board/>\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}