{"version":3,"sources":["components/Cell.js","utility/MazeGenerators/RecursiveDivision.js","utility/generateGraph.js","utility/DS/Queue.js","utility/DS/Graph.js","utility/DS/MinHeap.js","utility/Node.js","hooks/useNodeGrid.js","components/Board.js","utility/MazeGenerators/Random.js","App.js","index.js"],"names":["Cell","node","onMouseEnter","onMouseDown","onMouseLeave","onMouseUp","classes","useEffect","console","log","setClasses","row","col","push","className","join","id","recursiveDivision","grid","a","drawContourWalls","width","length","height","prohibitedCells","divide","chooseOrientation","orientation","prohibited","horizontal","whereCol","Math","ceil","random","whereRow","passCol","passRow","drawWall","newwidth","newheight","newwidth2","newheight2","startRow","startCol","i","cell","document","getElementById","classList","contains","isProhibitedCoord","add","isBorder","remove","updateProhibitedCells","j","getNeighbors","cellNotInGraph","isWall","neighbors","generateNodeGrid","nodesGrid","graph","Graph","getElementsByClassName","addVertex","generateGraph","startNode","targetNode","currentNode","isStart","isTarget","addEdge","dist","Queue","this","items","element","isEmpty","shift","str","noOfVertices","AdjList","Map","v","set","w","get","get_keys","keys","get_values","conc","startingNode","animations","visited","q","enqueue","getQueueElement","dequeue","get_List","n","neigh","predecessor","DFSUtil","vert","get_neighbours","get_elem","heap","MinHeap","item","pop","currentdist","adj","adjacentNode","d","f","g","manhattanDistance","print","h","abs","euclideanDistance","sqrt","pow","floor","selector","parentIndex","parentVal","pushedVal","swap","max","t","ret","temp","rightChildIndex","leftChildIndex","lowest","includes","indexOf","arr","Node","Infinity","markShortestPath","useNodeGrid","numRows","numCols","newNode","nodeGrid","useRef","current","resetGrid","reset","Board","useState","isMouseDown","setIsMouseDown","animating","setIsAnimating","isMovingTarget","setIsMovingTarget","isMovingStart","setIsMovingStart","onMouseEnterHandler","setWall","setAsStart","setAsTarget","onMouseDownHandler","isKeyValue","onMouseLeaveHandler","clear","onMouseUpHandler","Grid","map","rowNum","val","colNum","key","animate","count","intervalId","setInterval","markSearched","clearInterval","style","margin","Button","onClick","util","dfs","bfs","dijkstra","board","aStar","bestFirstSearch","gridTemplateRows","gridTemplateColumns","App","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.3ab4cbd1.chunk.js","sourcesContent":["import React, { useEffect } from \"react\";\nimport \"./Cell.css\";\n\nconst Cell = ({ node, onMouseEnter, onMouseDown, onMouseLeave, onMouseUp }) => {\n  let classes = [\"Cell\"];\n\n  useEffect(() => {\n    console.log(\"Cell UseEffect\");\n    node.setClasses();\n  }, []);\n\n  if (node.row === 10 && node.col === 10) {\n    classes.push(\"Filled\");\n  }\n  if (node.row === 10 && node.col === 30) {\n    classes.push(\"Target\");\n  }\n\n  return (\n    <div\n      className={classes.join(\" \")}\n      id={`${node.row} ${node.col}`}\n      onMouseDown={() => onMouseDown(node)}\n      onMouseEnter={() => onMouseEnter(node)}\n      onMouseLeave={() => onMouseLeave(node)}\n      onMouseUp={() => onMouseUp(node)}\n    ></div>\n  );\n};\n\nexport default Cell;\n","const HORIZONTAL = \"horizontal\";\nconst VERTICAL = \"vertical\";\n\nexport const recursiveDivision = async (grid) => {\n  drawContourWalls(grid);\n  const width = grid[0].length - 2; // Subtract 2 since we drew a contour\n  const height = grid.length - 2;\n  let prohibitedCells = [];\n  divide(\n    1,\n    1,\n    width,\n    height,\n    chooseOrientation(width, height),\n    prohibitedCells\n  );\n};\n\nconst divide = (col, row, width, height, orientation, prohibited) => {\n  if (width <= 2 || height <= 2 ) return;\n\n  const horizontal = orientation === HORIZONTAL;\n\n  // Where will the wall be drawn from?\n  let whereCol =\n    col + (horizontal ? 0 : Math.ceil(Math.random() * (width - 2))); // Rand number between the col and width\n\n  let whereRow =\n    row + (horizontal ? Math.ceil(Math.random() * (height - 2)) : 0); // Rand number between the row and height\n\n  // Where will the passage through the wall exist?\n  const passCol =\n    whereCol + (horizontal ? Math.ceil(Math.random() * (width - 1)) : 0); // Rand number between the col and width\n  const passRow =\n    whereRow + (horizontal ? 0 : Math.ceil(Math.random() * (height - 1))); // Rand number between the row and height\n\n  // How long will the wall be?\n  const length = horizontal ? width : height;\n\n  // Draw the walls\n  drawWall(\n    whereRow,\n    whereCol,\n    passRow,\n    passCol,\n    horizontal,\n    length,\n    prohibited\n  );\n\n  let newCol = row;\n  let newRow = col;\n\n  let newwidth = horizontal ? width : whereCol - col;\n  let newheight = horizontal ? whereRow - row : height;\n  divide(\n    newCol,\n    newRow,\n    newwidth,\n    newheight,\n    chooseOrientation(newwidth, newheight),\n    prohibited\n  );\n\n  let newCol2 = horizontal ? col : whereCol + 1;\n  let newRow2 = horizontal ? whereRow + 1 : row;\n\n  let newwidth2 = horizontal ? width : col + width - whereCol - 1;\n  let newheight2 = horizontal ? row + height - whereRow - 1 : height;\n\n  divide(\n    newCol2,\n    newRow2,\n    newwidth2,\n    newheight2,\n    chooseOrientation(newwidth2, newheight2),\n    prohibited\n  );\n};\n\nconst drawWall = (\n  startRow,\n  startCol,\n  passRow,\n  passCol,\n  horizontal,\n  length,\n  prohibited\n) => {\n \n  for (let i = 0; i < length; i++) {\n    const row = startRow + (horizontal ? 0 : i);\n    const col = startCol + (horizontal ? i : 0);\n\n    const cell = document.getElementById(`${row} ${col}`);\n\n    if (\n      cell &&\n      !cell.classList.contains(\"Target\") &&\n      !cell.classList.contains(\"Filled\") &&\n      !isProhibitedCoord(row, col, prohibited)\n    ) {\n      cell.classList.add(\"Wall\");\n    }\n  }\n\n  const cell = document.getElementById(`${passRow} ${passCol}`);\n  if (cell && !isBorder(passRow, passCol)) {\n    cell.classList.remove(\"Wall\");\n  }\n  updateProhibitedCells(passRow, passCol, horizontal, prohibited);\n};\n\nconst chooseOrientation = (width, height) => {\n  if (width < height) {\n    return HORIZONTAL;\n  }\n  return VERTICAL;\n};\n\nconst drawContourWalls = (grid) => {\n  for (let i = 0; i < grid.length; i++) {\n    let classes = document.getElementById(`${i} ${0}`).classList;\n    classes.add(\"Wall\");\n    classes = document.getElementById(`${i} ${grid[i].length - 1}`).classList;\n    classes.add(\"Wall\");\n  }\n\n  for (let j = 0; j < grid[0].length; j++) {\n    let classes = document.getElementById(`${0} ${j}`).classList;\n    classes.add(\"Wall\");\n    classes = document.getElementById(`${grid.length - 1} ${j}`).classList;\n    classes.add(\"Wall\");\n  }\n};\n\nconst updateProhibitedCells = (row, col, horizontal, prohibited) => {\n  if (!horizontal) {\n    prohibited.push([row, col + 1]);\n    prohibited.push([row, col - 1]);\n  } else {\n    prohibited.push([row + 1, col]);\n    prohibited.push([row - 1, col]);\n  }\n};\n\nconst isProhibitedCoord = (row, col, prohibited) => {\n  for (let i = 0; i < prohibited.length; i++) {\n    if (prohibited[i][0] === row && prohibited[i][1] === col) return true;\n  }\n  return false;\n};\n\nconst isBorder = (row, col) => {\n  return row === 0 || row === 19 || col === 0 || col === 49;\n}\n","import { Graph } from \"./index\";\n\nconst getNeighbors = (grid, row, col) => {\n  const cellNotInGraph = (row, col) => {\n    return grid[row][col].isWall();\n  };\n\n  if (cellNotInGraph(row, col)) return [];\n  let neighbors = [];\n\n  if (row > 0 && !cellNotInGraph(row - 1, col)) {\n    // N\n    neighbors.push(grid[row - 1][col]);\n  }\n  if (col > 0 && !cellNotInGraph(row, col - 1)) {\n    // W\n    neighbors.push(grid[row][col - 1]);\n  }\n  if (row < grid.length - 1 && !cellNotInGraph(row + 1, col)) {\n    // S\n    neighbors.push(grid[row + 1][col]);\n  }\n  if (col < grid[row].length - 1 && !cellNotInGraph(row, col + 1)) {\n    // E\n    neighbors.push(grid[row][col + 1]);\n  }\n\n  return neighbors;\n};\n\nexport const calculateNumVertices = () => {\n  const numCells = document.getElementsByClassName(\"Cell\").length;\n  const numWalls = document.getElementsByClassName(\"Wall\").length;\n  return numCells - numWalls;\n};\n\nexport const generateNodeGrid = (grid) => {\n  const nodesGrid = [];\n  const graph = new Graph(calculateNumVertices());\n\n  for (let row in grid) {\n    nodesGrid[row] = [];\n    for (let col in grid[row]) {\n      graph.addVertex(grid[row][col]);\n    }\n  }\n  return graph;\n};\n\nexport const generateGraph = (nodesGrid) => {\n  let startNode = null;\n  let targetNode = null;\n\n  const graph = generateNodeGrid(nodesGrid);\n\n  for (let row = 0; row < nodesGrid.length; row++) {\n    for (let col = 0; col < nodesGrid[row].length; col++) {\n      const currentNode = nodesGrid[row][col];\n\n      if (!currentNode.isWall()) {\n        if (currentNode.isStart()) startNode = currentNode;\n        if(currentNode.isTarget()) targetNode = currentNode;\n        const neighbors = getNeighbors(nodesGrid, row, col);\n\n        for (let i in neighbors) {\n          graph.addEdge(currentNode, neighbors[i]);\n        }\n      }\n    }\n  }\n  startNode.dist = 0;\n  return { graph, startNode, targetNode };\n};\n","// Queue class\nexport class Queue {\n  // Array is used to implement a Queue\n  constructor() {\n    this.items = [];\n  }\n\n  // enqueue(item)\n  enqueue(element) {\n    // adding element to the queue\n    this.items.push(element);\n  }\n\n  // dequeue()\n  dequeue() {\n    // removing element from the queue\n    // returns underflow when called\n    // on empty queue\n    if (this.isEmpty()) return \"Underflow\";\n    return this.items.shift();\n  }\n\n  // front()\n  front() {\n    // returns the Front element of\n    // the queue without removing it.\n    if (this.isEmpty()) return \"No elements in Queue\";\n    return this.items[0];\n  }\n\n  // isEmpty()\n  isEmpty() {\n    // return true if the queue is empty.\n    return this.items.length === 0;\n  }\n\n  // printQueue()\n  printQueue() {\n    var str = \"\";\n    for (var i = 0; i < this.items.length; i++) str += this.items[i] + \" \";\n    return str;\n  }\n}\n\n// // creating object for queue class \n// var queue = new Queue(); \n              \n  \n// // Testing dequeue and pop on an empty queue \n// // returns Underflow \n// console.log(queue.dequeue()); \n  \n// // returns true \n// console.log(queue.isEmpty()); \n  \n// // Adding elements to the queue \n// // queue contains [10, 20, 30, 40, 50] \n// queue.enqueue(10); \n// queue.enqueue(20); \n// queue.enqueue(30); \n// queue.enqueue(40); \n// queue.enqueue(50); \n// queue.enqueue(60); \n  \n// // returns 10 \n// console.log(queue.front()); \n  \n// // removes 10 from the queue \n// // queue contains [20, 30, 40, 50, 60] \n// console.log(queue.dequeue()); \n  \n// // returns 20 \n// console.log(queue.front()); \n  \n// // removes 20 \n// // queue contains [30, 40, 50, 60] \n// console.log(queue.dequeue()); \n  \n// // printing the elements of the queue \n// // prints [30, 40, 50, 60] \n// console.log(queue.printQueue()); \n","import { Queue } from \"./Queue\";\nimport { MinHeap } from \"../index\";\n\nexport class Graph {\n  constructor(noOfVertices) {\n    this.noOfVertices = noOfVertices;\n    this.AdjList = new Map();\n  }\n\n  addVertex(v) {\n    // initialize the adjacent list with a\n    // null array\n    this.AdjList.set(v, []);\n  }\n\n  addEdge(v, w) {\n    // get the list for vertex v and put the\n    // vertex w denoting edge between v and w\n    this.AdjList.get(v).push(w);\n\n    // Since graph is undirected,\n    // add an edge from w to v also\n    // this.AdjList.get(w).push(v);\n  }\n\n  printGraph() {\n    // get all the vertices\n    var get_keys = this.AdjList.keys();\n\n    // iterate over the vertices\n    for (var i of get_keys) {\n      // great the corresponding adjacency list\n      // for the vertex\n      var get_values = this.AdjList.get(i);\n      var conc = \"\";\n\n      // iterate over the adjacency list\n      // concatenate the values into a string\n      for (var j of get_values) conc += j + \" \";\n\n      // print the vertex and its adjacency list\n      console.log(i + \" -> \" + conc);\n    }\n  }\n\n  // bfs(v)\n  // function to performs BFS\n  bfs(startingNode) {\n    // create a visited array\n    const animations = [];\n\n    var visited = [];\n    for (var i = 0; i < this.noOfVertices; i++) visited[i] = false;\n\n    // Create an object for queue\n    var q = new Queue();\n\n    // add the starting node to the queue\n    visited[startingNode] = true;\n    q.enqueue(startingNode);\n\n    // loop until queue is element\n    while (!q.isEmpty()) {\n      // get the element from the queue\n      var getQueueElement = q.dequeue();\n\n      // passing the current vertex to callback funtion\n      // console.log(getQueueElement);\n\n      // get the adjacent list for current vertex\n      var get_List = this.AdjList.get(getQueueElement);\n\n      // loop through the list and add the element to the\n      // queue if it is not processed yet\n      for (var n in get_List) {\n        var neigh = get_List[n];\n\n        if (!visited[neigh]) {\n          neigh.predecessor = getQueueElement;\n          animations.push(neigh);\n          visited[neigh] = true;\n          q.enqueue(neigh);\n        }\n      }\n    }\n\n    return animations;\n  }\n\n  // dfs(v)\n  // Main DFS method\n  dfs(startingNode) {\n    const animations = [];\n\n    var visited = [];\n    for (var i = 0; i < this.noOfVertices; i++) visited[i] = false;\n\n    this.DFSUtil(startingNode, visited, animations);\n\n    return animations;\n  }\n\n  // Recursive function which process and explore\n  // all the adjacent vertex of the vertex with which it is called\n  DFSUtil(vert, visited, animations) {\n    visited[vert] = true;\n    console.log(vert);\n\n    var get_neighbours = this.AdjList.get(vert);\n\n    for (var i in get_neighbours) {\n      var get_elem = get_neighbours[i];\n      if (!visited[get_elem]) {\n        get_elem.predecessor = vert;\n        animations.push(get_elem);\n        this.DFSUtil(get_elem, visited, animations);\n      }\n    }\n  }\n\n  //dijkstra solve graph starting at s\n  dijkstra(startNode) {\n    const animations = [];\n\n    const heap = new MinHeap((item) => item.dist);\n\n    heap.push(startNode);\n\n    while (!heap.isEmpty()) {\n      //for each existing solution\n      const currentNode = heap.pop();\n\n      var currentdist = currentNode.dist;\n      var adj = this.AdjList.get(currentNode); // get neighbors\n\n      //for each of its adjacent nodes...\n      for (var a in adj) {\n        const adjacentNode = adj[a];\n\n        //choose nearest node with lowest *total* cost\n        var d = 1 + currentdist;\n\n        if (d < adjacentNode.dist && !heap.contains(adjacentNode)) {\n          animations.push(adjacentNode);\n          heap.push(adjacentNode);\n          //reference parent\n          adjacentNode.predecessor = currentNode;\n          adjacentNode.dist = d;\n        }\n      }\n    }\n    return animations;\n  }\n\n  aStar(startNode, targetNode) {\n    const animations = [];\n\n    const heap = new MinHeap((item) => item.f);\n    startNode.g = 0;\n    this.manhattanDistance(startNode, targetNode);\n\n    heap.push(startNode);\n\n    heap.print();\n\n    while (!heap.isEmpty()) {\n      const currentNode = heap.pop();\n\n      var currentdist = currentNode.dist;\n      var adj = this.AdjList.get(currentNode); // get neighbors\n\n      //for each of its adjacent nodes...\n      for (var a in adj) {\n        const adjacentNode = adj[a];\n\n        //choose nearest node with lowest *total* cost\n        var d = 1 + currentdist;\n\n        if (d < adjacentNode.dist && !heap.contains(adjacentNode)) {\n          animations.push(adjacentNode);\n          this.manhattanDistance(adjacentNode, targetNode);\n          heap.push(adjacentNode);\n          //reference parent\n          adjacentNode.predecessor = currentNode;\n          adjacentNode.dist = d;\n          if (adjacentNode.isTarget()) return animations;\n        }\n      }\n    }\n\n    return animations;\n  }\n\n  manhattanDistance(node, targetNode) {\n    const h =\n      Math.abs(node.col - targetNode.col) + Math.abs(node.row - targetNode.row);\n    node.h = h;\n    node.f = node.g + node.h;\n  }\n\n  bestFirstSearch(startNode, targetNode) {\n    const animations = [];\n\n    const heap = new MinHeap((item) => item.f);\n    startNode.g = 0;\n    this.euclideanDistance(startNode, targetNode);\n\n    heap.push(startNode);\n\n    heap.print();\n\n    while (!heap.isEmpty()) {\n      const currentNode = heap.pop();\n\n      var currentdist = currentNode.dist;\n      var adj = this.AdjList.get(currentNode); // get neighbors\n\n      //for each of its adjacent nodes...\n      for (var a in adj) {\n        const adjacentNode = adj[a];\n\n        //choose nearest node with lowest *total* cost\n        var d = 1 + currentdist;\n\n        if (d < adjacentNode.dist && !heap.contains(adjacentNode)) {\n          animations.push(adjacentNode);\n\n          this.euclideanDistance(adjacentNode, targetNode);\n\n          heap.push(adjacentNode);\n\n          //reference parent\n          adjacentNode.predecessor = currentNode;\n          adjacentNode.dist = d;\n          if (adjacentNode.isTarget()) return animations;\n        }\n      }\n    }\n\n    return animations;\n  }\n\n  euclideanDistance(node, targetNode) {\n    const h = Math.sqrt(\n      Math.pow(node.col - targetNode.col, 2) +\n        Math.pow(node.row - targetNode.row, 2)\n    );\n    node.h = Math.floor(h);\n    node.f = node.g + node.h;\n  }\n}\n","export class MinHeap {\n  constructor(selector) {\n    this.items = [];\n    this.selector = selector;\n  }\n\n  seek() {\n    return this.items[0];\n  }\n\n  push(item) {\n    let i = this.items.length;\n    this.items.push(item);\n\n    let parentIndex = Math.floor((i + 1) / 2 - 1);\n\n    if (parentIndex < 0) parentIndex = 0;\n\n    // console.log(\"ParentIndex\", parentIndex);\n\n    let parentVal = this.selector(this.items[parentIndex]);\n    const pushedVal = this.selector(this.items[i]);\n\n    // console.log(\"ParentVal, parentIndex:\", parentVal, parentIndex);\n    // console.log(\"PushedVal\", pushedVal);\n\n    while (i > 0 && parentVal > pushedVal) {\n      parentIndex = Math.floor((i + 1) / 2 - 1);\n      // console.log(\n      //   \"INSIDE LOOP ParentVal, parentIndex:\",\n      //   parentVal,\n      //   parentIndex\n      // );\n\n      this.swap(i, parentIndex);\n\n      i = parentIndex;\n      // console.log(\n      //   \"New INSIDE LOOP parentIndex:\",\n      //   Math.max(Math.floor((i + 1) / 2 - 1), 0)\n      // );\n\n      parentVal = this.selector(\n        this.items[Math.max(Math.floor((i + 1) / 2 - 1), 0)]\n      );\n    }\n\n    // this.print();\n  }\n\n  swap(i, j) {\n    let t = this.items[i];\n    this.items[i] = this.items[j];\n    this.items[j] = t;\n  }\n\n  pop() {\n    // console.log(\"Items before pop:\", this.items);\n    if (this.items.length <= 1) return this.items.pop(); //If it is the last element pop it\n    const ret = this.items[0]; // What we will return\n    let temp = this.items.pop();\n    this.items[0] = temp; // Place last element in array at front\n\n    // console.log(\"Items after pop:\", this.items); // Good till here\n    let i = 0; // We adjust heap from top to down\n\n    while (true) {\n      let rightChildIndex = (i + 1) * 2;\n      let leftChildIndex = (i + 1) * 2 - 1;\n\n      // console.log(\"rightIndex\", rightChildIndex);\n      // console.log(\"rightValue\", this.items[rightChildIndex]);\n      // console.log(\"leftIndex\", leftChildIndex);\n      // console.log(\"leftValue\", this.items[leftChildIndex]);\n      let lowest = rightChildIndex;\n\n      if (\n        leftChildIndex >= this.items.length &&\n        rightChildIndex >= this.items.length\n      )\n        break;\n      if (leftChildIndex >= this.items.length) lowest = rightChildIndex;\n      if (rightChildIndex >= this.items.length) lowest = leftChildIndex;\n\n      if (\n        !(leftChildIndex >= this.items.length) &&\n        !(rightChildIndex >= this.items.length)\n      ) {\n        lowest =\n          this.selector(this.items[rightChildIndex]) <\n          this.selector(this.items[leftChildIndex])\n            ? rightChildIndex\n            : leftChildIndex;\n      } // Find the smallest child\n\n      // If the parent is greater than the smallest child: swap\n      if (this.selector(this.items[i]) > this.selector(this.items[lowest])) {\n        this.swap(i, lowest);\n        i = lowest;\n      } else break; // We have finished setting up the heap\n    }\n\n    // Return topmost element\n    return ret;\n  }\n\n  contains(item) {\n    return this.items.includes(item);\n  }\n\n  isEmpty() {\n    return this.items.length === 0;\n  }\n\n  delete(item) {\n    let i = this.items.indexOf(item);\n    // heapify\n    this.items[i] = this.items.pop();\n    while (true) {\n      let lowest =\n        this.selector(this.items[(i + 1) * 2]) <\n        this.selector(this.items[(i + 1) * 2 - 1])\n          ? (i + 1) * 2\n          : (i + 1) * 2 - 1;\n      if (this.selector(this.items[i]) > this.selector(this.items[lowest])) {\n        let t = this.items[i];\n        this.items[i] = this.items[lowest];\n        this.items[lowest] = t;\n        i = lowest;\n      } else break;\n    }\n  }\n\n  print() {\n    for (let i = 0; i < this.items.length; i++) {\n      console.log(this.items[i]);\n    }\n  }\n\n  heapify(arr) {\n    for (let i = 0; i < arr.length; i++) {\n      this.push(arr[i]);\n    }\n  }\n}\n\n// const heap = new MinHeap((x) => x.dist);\n// heap.heapify([6, 3, 6, 9, 43, 0, 8, 0, 8]);\n// console.log(heap);\n// console.log(heap.isEmpty());\n\n// heap.heapify([1, 2, 7, 4, 8, 0, 4, 2, 7, 3]);\n\n// heap.heapify([\n//   { dist: 1 },\n//   { dist: 2 },\n//   { dist: 7 },\n//   { dist: 4 },\n//   { dist: 8 },\n//   { dist: 0 },\n//   { dist: 4 },\n//   { dist: 2 },\n//   { dist: 7 },\n//   { dist: 3 },\n// ]);\n\n// heap.heapify([\n//   { dist: 1 },\n//   { dist: 2 },\n//   { dist: 7 },\n//   { dist: 4 },\n//   { dist: 8 },\n//   { dist: 0 },\n//   { dist: 4 },\n//   { dist: 2 },\n//   { dist: 7 },\n//   { dist: 3 },\n//   { dist: 23 },\n//   { dist: 200 },\n//   { dist: -1 },\n// ]);\n\n// heap.print();\n// // const a = heap.pop()\n// // heap.pop()\n// // heap.pop()\n\n// console.log(heap.items);\n\n// while (!heap.isEmpty()) {\n//   // console.log(\"Length\", heap.items.length);\n//   const a = heap.pop();\n//   console.log(\"Value:\", a);\n//   // console.log(\"Length\", heap.items.length);\n// }\n","export default class Node {\n  \n  constructor(row, col) {\n    this.row = row;\n    this.col = col;\n    this.predecessor = null;\n    this.dist = Infinity;\n    this.g = 1;\n    this.h = null;\n    this.f = null;\n  }\n\n  setClasses() {\n    this.cell = document.getElementById(`${this.row} ${this.col}`);\n    this.classes = this.cell.classList;\n  }\n\n  toString() {\n    return \"(\" + this.row + \" \" + this.col + \")\";\n  }\n\n  setWall() {\n    if (this.isTarget() || this.isStart()) return;\n    this.classes.add(\"Wall\");\n  }\n\n  setAsTarget() {\n    this.classes.add(\"Target\");\n  }\n\n  setAsStart() {\n    this.classes.add(\"Filled\");\n  }\n\n  markSearched() {\n    if (this.isTarget()) return;\n    this.classes.add(\"Searched\");\n  }\n\n  reset() {\n    this.classes.remove(\"ShortestPath\");\n    this.classes.remove(\"Wall\");\n    this.classes.remove(\"Searched\");\n    this.predecessor = null;\n    this.dist = Infinity;\n  }\n\n  clear() {\n    this.classes.remove(\"Target\");\n    this.classes.remove(\"Filled\");\n  }\n\n  isTarget() {\n    return this.classes.contains(\"Target\");\n  }\n\n  isStart() {\n    return this.classes.contains(\"Filled\");\n  }\n\n  isKeyValue(){\n    return this.isTarget() || this.isStart()\n  }\n\n  isWall() {\n    return this.classes.contains(\"Wall\");\n  }\n\n  isPartOfGraph() {\n    return !this.isWall();\n  }\n\n  markShortestPath() {\n    if (!this.isTarget() && !this.isStart()) {\n      this.classes.remove(\"Searched\");\n      this.classes.add(\"ShortestPath\");\n    }\n    if (this.predecessor != null) {\n      this.predecessor.markShortestPath();\n    }\n  }\n}\n","import { useRef } from \"react\";\nimport Node from \"../utility/Node\";\n\nconst generateNodeGrid = (numRows, numCols) => {\n  const nodesGrid = [];\n\n  for (let row = 0; row < numRows; row++) {\n    nodesGrid[row] = [];\n    for (let col = 0; col < numCols; col++) {\n      const newNode = new Node(row, col);\n      nodesGrid[row][col] = newNode;\n    }\n  }\n\n  return nodesGrid;\n};\n\nconst useNodeGrid = () => {\n  const nodesGrid = generateNodeGrid(20, 50);\n  const nodeGridRef = useRef(nodesGrid);\n  const nodeGrid = nodeGridRef.current;\n\n  const resetGrid = () => {\n      for(let row in nodeGrid){\n          for(let col in nodeGrid[row]){\n              nodeGrid[row][col].reset();\n          }\n      }\n  }\n  return { nodeGrid, resetGrid };\n};\n\nexport default useNodeGrid;\n","import React, { useState, Fragment } from \"react\";\nimport Cell from \"./Cell\";\nimport Button from \"@material-ui/core/Button\";\nimport * as util from \"../utility/index\";\nimport \"./Board.css\";\nimport useNodeGrid from \"../hooks/useNodeGrid\";\n\nconst ROWS_INIT = 20;\nconst COLS_INIT = 50;\n\nconst Board = () => {\n  const { nodeGrid, resetGrid } = useNodeGrid();\n  const [isMouseDown, setIsMouseDown] = useState(false);\n  const [animating, setIsAnimating] = useState(true);\n  const [isMovingTarget, setIsMovingTarget] = useState(false);\n  const [isMovingStart, setIsMovingStart] = useState(false);\n\n  const onMouseEnterHandler = (node) => {\n    if (isMouseDown && !isMovingStart && !isMovingTarget) {\n      node.setWall();\n    }\n    if (isMouseDown && isMovingStart) node.setAsStart();\n    if(isMouseDown && isMovingTarget) node.setAsTarget();\n  };\n\n  const onMouseDownHandler = (node) => {\n    setIsMouseDown(true);\n    if (!node.isKeyValue()) return node.setWall();\n    if (node.isStart()) return setIsMovingStart(true);\n    setIsMovingTarget(true);\n  };\n\n  const onMouseLeaveHandler = (node) => {\n    if (isMovingStart || isMovingTarget) node.clear();\n  };\n\n  const onMouseUpHandler = () => {\n    setIsMouseDown(false);\n    setIsMovingStart(false);\n    setIsMovingTarget(false);\n    console.log(\"Cell on mouse up\");\n  };\n\n  let Grid = nodeGrid.map((row, rowNum) => {\n    return row.map((val, colNum) => {\n      return (\n        <Cell\n          key={val}\n          node={nodeGrid[rowNum][colNum]}\n          onMouseEnter={onMouseEnterHandler}\n          onMouseDown={onMouseDownHandler}\n          onMouseUp={onMouseUpHandler}\n          onMouseLeave={onMouseLeaveHandler}\n        />\n      );\n    });\n  });\n\n  const BFS = () => {\n    setIsAnimating(false);\n    const { startNode, graph } = util.generateGraph(nodeGrid);\n    const animations = graph.bfs(startNode);\n    animate(animations);\n  };\n\n  const DFS = () => {\n    setIsAnimating(false);\n    const { startNode, graph } = util.generateGraph(nodeGrid);\n    const animations = graph.dfs(startNode);\n    animate(animations);\n  };\n\n  const Dijkstra = () => {\n    setIsAnimating(false);\n    const { startNode, graph } = util.generateGraph(nodeGrid);\n    const animations = graph.dijkstra(startNode);\n    animate(animations);\n  };\n\n  const AStar = () => {\n    setIsAnimating(false);\n    const { startNode, graph, targetNode } = util.generateGraph(nodeGrid);\n    const animations = graph.aStar(startNode, targetNode);\n    animate(animations);\n  };\n\n  const bestFirstSearch = () => {\n    setIsAnimating(false);\n    const { startNode, graph, targetNode } = util.generateGraph(nodeGrid);\n    const animations = graph.bestFirstSearch(startNode, targetNode);\n    animate(animations);\n  };\n\n  const clear = () => {\n    if (!animating) return;\n    resetGrid();\n  };\n\n  const doRandomMaze = () => {\n    if (!animating) return;\n    clear();\n    util.randomMaze(nodeGrid);\n  };\n\n  const doRecursiveDivision = () => {\n    if (!animating) return;\n    clear();\n    util.recursiveDivision(nodeGrid);\n  };\n\n  const animate = (animations) => {\n    let count = 0;\n\n    const intervalId = setInterval(() => {\n      const node = animations[count];\n\n      node.markSearched();\n      node.isTarget() && node.markShortestPath();\n\n      count++;\n\n      if (count >= animations.length) {\n        setIsAnimating(true);\n        clearInterval(intervalId);\n      }\n    }, 10);\n  };\n\n  return (\n    <Fragment>\n      <div style={{ margin: \"auto\" }}>\n        <Button onClick={DFS}>Do DFS</Button>\n        <Button onClick={BFS}>Do BFS</Button>\n        <Button onClick={Dijkstra}>Dijkstra</Button>\n        <Button onClick={doRandomMaze}>Random Maze</Button>\n        <Button onClick={doRecursiveDivision}>Recursive Division</Button>\n        <Button onClick={AStar}>A*</Button>\n        <Button onClick={bestFirstSearch}>Greedy Best First Search</Button>\n        <Button onClick={clear}>Clear</Button>\n      </div>\n      <div\n        className=\"Board\"\n        style={{\n          gridTemplateRows: `repeat(${ROWS_INIT}, 1fr)`,\n          gridTemplateColumns: `repeat(${COLS_INIT}, 1fr)`,\n        }}\n      >\n        {Grid}\n      </div>\n    </Fragment>\n  );\n};\n\nexport default Board;\n","export const randomMaze = (board) => {\n  for (let row = 0; row < board.length; row++) {\n    for (let col = 0; col < board[row].length; col++) {\n        if (Math.random() <= 0.3) {\n          const node = board[row][col];\n          node.setWall()\n        }\n    }\n  }\n};\n","import React from 'react';\nimport './App.css';\nimport Board from \"./components/Board\"\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <h1 style={{margin: \"auto\"}}>Graph Algorithm Visualization</h1>\n      <Board/>\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}