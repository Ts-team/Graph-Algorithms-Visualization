{"version":3,"sources":["components/Navigation/NavigationItems/NavigationItem/NavigationItem.module.css","App.module.css","components/Navigation/Toolbar/Toolbar.module.css","components/Cell.js","utility/MazeGenerators/Contour.js","utility/MazeGenerators/RecursiveDivision.js","utility/generateGraph.js","utility/DS/Queue.js","utility/DS/Graph.js","utility/DS/MinHeap.js","utility/constants.js","utility/Node.js","hooks/useNodeGrid.js","components/Navigation/NavigationItems/NavigationItem/NavigationItem.js","components/Navigation/NavigationItems/Dropdown/DropDown.js","components/Navigation/NavigationItems/Subnav/Subnav.js","components/Navigation/NavigationItems/Dropdown/DropItem/DropItem.js","components/Navigation/NavigationItems/NavigationItems.js","components/Navigation/Toolbar/Toolbar.js","components/Board.js","utility/MazeGenerators/Random.js","components/UI/Backdrop/Backdrop.js","components/UI/CustomDialog/CustomDialog.js","App.js","index.js"],"names":["module","exports","Cell","node","onMouseEnter","onMouseDown","onMouseLeave","onMouseUp","classes","useEffect","console","log","setClasses","row","col","push","className","join","id","drawContourWalls","grid","i","add","length","j","divide","width","height","orientation","prohibited","horizontal","whereCol","randBetween","whereRow","passCol","passRow","drawWall","updateProhibitedCells","newwidth","newheight","neworientation","chooseOrientation","startRow","startCol","cell","isKeyValue","min","max","Math","floor","random","getNeighbors","cellNotInGraph","is","neighbors","generateNodeGrid","nodesGrid","graph","Graph","document","getElementsByClassName","addVertex","generateGraph","startNode","targetNode","currentNode","addEdge","dist","Queue","this","items","element","isEmpty","shift","str","noOfVertices","AdjList","Map","v","set","w","get","get_keys","keys","get_values","conc","startingNode","animations","visited","q","enqueue","getQueueElement","dequeue","get_List","n","neigh","predecessor","withAnimation","DFSUtil","vert","get_neighbours","get_elem","hasSecond","heap","MinHeap","item","finishedAnimating","pop","currentdist","adj","a","adjacentNode","d","contains","dijkstra","f","g","manhattanDistance","print","markSearched2Done","markShortestPath","h","abs","euclideanDistance","sqrt","pow","selector","parentIndex","parentVal","pushedVal","swap","t","ret","temp","rightChildIndex","leftChildIndex","lowest","includes","indexOf","arr","GREEDY_BFS","BFS","Node","Infinity","s","remove","getElementById","classList","forEach","name","useNodeGrid","numRows","numCols","newNode","nodeGrid","useRef","current","resetGrid","reset","removeVisuals","paintInDistance","removeClasses","resetDistance","NavigationItem","children","clicked","onClick","Btn","DropDown","title","moreInfo","Subnav","DropItem","NavigationItems","setAlgorithm","executeAlgorithm","algorithm","mazeGen","settingSecondTarget","openDialog","clear","setDeleting","alert","cts","toolbar","props","Toolbar","Board","useState","isMouseDown","setIsMouseDown","animating","setIsAnimating","isMovingTarget","setIsMovingTarget","isMovingSecondTarget","setIsMovingSecondTarget","isMovingStart","setIsMovingStart","setSettingSecondTarget","hasSecondTarget","setHasSecondTarget","numTargets","setNumTargets","prevAlgorithm","setPrevAlgorithm","canPlaceWall","setCanPlaceWall","isDeleting","setIsDeleting","onMouseEnterHandler","setAsSecondTarget","setWall","setAsTarget","AStar","util","bestFirstSearch","DFS","handleTargetMove","onMouseDownHandler","onMouseLeaveHandler","removeClass","onMouseUpHandler","Grid","map","rowNum","val","colNum","key","bfs","dfs","Dijkstra","aStar","removeVisualization","animate","count","intervalId","setInterval","markSearched2","clearInterval","type","prohibitedCells","board","style","gridTemplateRows","gridTemplateColumns","backdrop","cssClasses","show","CustomDialog","isOpen","handleClose","subtitle","howToPlay","Dialog","fullWidth","maxWidth","open","onClose","aria-labelledby","DialogTitle","DialogContent","DialogContentText","DialogActions","Button","color","App","setIsOpen","handleDialogOpen","customDialog","Paper","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.1172070f.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"NavigationItem\":\"NavigationItem_NavigationItem__2SpXc\",\"Btn\":\"NavigationItem_Btn__3xhRr\",\"navbar\":\"NavigationItem_navbar__2rE4b\",\"NavigationItem-content\":\"NavigationItem_NavigationItem-content__2c_Zw\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"App\":\"App_App__16ZpL\",\"Container\":\"App_Container__10KOh\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"Toolbar\":\"Toolbar_Toolbar__ApScI\",\"dropdown\":\"Toolbar_dropdown__3LTS7\",\"dropbtn\":\"Toolbar_dropbtn__30BvA\"};","import React, { useEffect } from \"react\";\nimport \"./Cell.css\";\n\nconst Cell = ({ node, onMouseEnter, onMouseDown, onMouseLeave, onMouseUp }) => {\n  let classes = [\"Cell\"];\n  let icon = null;\n\n  useEffect(() => {\n    console.log(\"Cell UseEffect\");\n    node.setClasses();\n  }, [node]);\n\n  if (node.row === 10 && node.col === 10) {\n    classes.push(\"Start\");\n  }\n  if (node.row === 10 && node.col === 30) {\n    classes.push(\"Target\");\n  }\n\n  return (\n    <div\n      className={classes.join(\" \")}\n      id={`${node.row} ${node.col}`}\n      onMouseDown={() => onMouseDown(node)}\n      onMouseEnter={() => onMouseEnter(node)}\n      onMouseLeave={() => onMouseLeave(node)}\n      onMouseUp={() => onMouseUp(node)}\n    >\n      {icon}\n    </div>\n  );\n};\n\nexport default Cell;\n","export const drawContourWalls = (grid) => {\n  for (let i in grid) {\n    grid[i][0].add(\"Wall\");\n    grid[i][grid[i].length - 1].add(\"Wall\");\n  }\n\n  for (let j in grid[0]) {\n    grid[0][j].add(\"Wall\");\n    grid[grid.length - 1][j].add(\"Wall\");\n  }\n};\n","import { drawContourWalls } from \"./Contour\";\n\nconst HORIZONTAL = \"horizontal\";\nconst VERTICAL = \"vertical\";\n\nexport const recursiveDivision = (grid) => {\n  drawContourWalls(grid);\n  const width = grid[0].length - 2; // Subtract 2 since we drew a contour\n  const height = grid.length - 2;\n  let prohibitedCells = []; // Walls that clot the maze\n\n  divide(1,1,width, height, chooseOrientation(width, height), prohibitedCells, grid)\n\n  // Remove prohibited cells so that all of the board is reachable\n  for (let i in prohibitedCells) {\n    const row = prohibitedCells[i][0];\n    const col = prohibitedCells[i][1];\n    grid[row][col].remove([\"Wall\"]);\n  }\n};\n\nconst divide = (\n  row,\n  col,\n  width,\n  height,\n  orientation,\n  prohibited,\n  grid\n) => {\n  if (width <= 2 || height <= 2) return; //Maybe have a function that paints?\n  // Is the wall to be drawn horizontal?\n  const horizontal = orientation === HORIZONTAL;\n\n  // Where will the wall be drawn from?\n  let whereCol = col + (horizontal ? 0 : randBetween(2, width - 2)); // Rand number between the col and width\n  let whereRow = row + (horizontal ? randBetween(2, height - 2) : 0); // Rand number between the row and height\n\n  // Where will the passage through the wall exist?\n  const passCol = whereCol + (horizontal ? randBetween(0, width - 1) : 0); // Rand number between the col and width\n\n  const passRow = whereRow + (horizontal ? 0 : randBetween(0, height - 1)); // Rand number between the row and height\n\n  // How long will the wall be?\n  const length = horizontal ? width : height;\n\n  // Draw the walls\n  drawWall(whereRow, whereCol, horizontal, length, grid);\n  updateProhibitedCells(passRow, passCol, horizontal, prohibited);\n\n  // get first recursive call data\n  let newwidth = horizontal ? width : whereCol - col;\n  let newheight = horizontal ? whereRow - row : height;\n  let neworientation = chooseOrientation(newwidth, newheight);\n  \n  divide(row, col, newwidth, newheight, neworientation, prohibited,grid);\n  \n  // get second recursive call data\n  let newCol = horizontal ? col : whereCol + 1;\n  let newRow = horizontal ? whereRow + 1 : row;\n\n  newwidth = horizontal ? width : col + width - whereCol - 1;\n  newheight = horizontal ? row + height - whereRow - 1: height;\n  neworientation = chooseOrientation(newwidth, newheight);\n\n  divide(newRow, newCol, newwidth, newheight, neworientation, prohibited,grid);\n};\n\nconst drawWall = (startRow, startCol, horizontal, length, grid) => {\n  for (let i = 0; i < length; i++) {\n    const row = startRow + (horizontal ? 0 : i);\n    const col = startCol + (horizontal ? i : 0);\n\n    const cell = grid[row][col];\n    if (!cell.isKeyValue()) cell.add(\"Wall\");\n  }\n};\n\nconst chooseOrientation = (width, height) => {\n  if (width < height) return HORIZONTAL;\n  return VERTICAL;\n};\n\nconst updateProhibitedCells = (row, col, horizontal, prohibited) => {\n  prohibited.push([row, col]);\n  if (!horizontal) {\n    prohibited.push([row, col + 1]);\n    prohibited.push([row, col - 1]);\n  } else {\n    prohibited.push([row + 1, col]);\n    prohibited.push([row - 1, col]);\n  }\n};\n\nfunction randBetween(min, max) {\n  // min and max included\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\n","import { Graph } from \"./index\";\n\nconst getNeighbors = (grid, row, col) => {\n  const cellNotInGraph = (row, col) => {\n    return grid[row][col].is(\"Wall\");\n  };\n\n  if (cellNotInGraph(row, col)) return [];\n  let neighbors = [];\n\n  if (row > 0 && !cellNotInGraph(row - 1, col)) {\n    // N\n    neighbors.push(grid[row - 1][col]);\n  }\n  if (col > 0 && !cellNotInGraph(row, col - 1)) {\n    // W\n    neighbors.push(grid[row][col - 1]);\n  }\n  if (row < grid.length - 1 && !cellNotInGraph(row + 1, col)) {\n    // S\n    neighbors.push(grid[row + 1][col]);\n  }\n  if (col < grid[row].length - 1 && !cellNotInGraph(row, col + 1)) {\n    // E\n    neighbors.push(grid[row][col + 1]);\n  }\n\n  return neighbors;\n};\n\nexport const calculateNumVertices = () => {\n  const numCells = document.getElementsByClassName(\"Cell\").length;\n  const numWalls = document.getElementsByClassName(\"Wall\").length;\n  return numCells - numWalls;\n};\n\nexport const generateNodeGrid = (grid) => {\n  const nodesGrid = [];\n  const graph = new Graph(calculateNumVertices());\n\n  for (let row in grid) {\n    nodesGrid[row] = [];\n    for (let col in grid[row]) {\n      graph.addVertex(grid[row][col]);\n    }\n  }\n  return graph;\n};\n\nexport const generateGraph = (nodesGrid) => {\n  let startNode = null;\n  let targetNode = null;\n\n  const graph = generateNodeGrid(nodesGrid);\n\n  for (let row = 0; row < nodesGrid.length; row++) {\n    for (let col = 0; col < nodesGrid[row].length; col++) {\n      const currentNode = nodesGrid[row][col];\n\n      if (!currentNode.is(\"Wall\")) {\n        if (currentNode.is(\"Start\")) startNode = currentNode;\n        if(currentNode.is(\"Target\")) targetNode = currentNode;\n        const neighbors = getNeighbors(nodesGrid, row, col);\n\n        for (let i in neighbors) {\n          graph.addEdge(currentNode, neighbors[i]);\n        }\n      }\n    }\n  }\n  startNode.dist = 0;\n  return { graph, startNode, targetNode };\n};\n","// Queue class\nexport class Queue {\n  // Array is used to implement a Queue\n  constructor() {\n    this.items = [];\n  }\n\n  // enqueue(item)\n  enqueue(element) {\n    // adding element to the queue\n    this.items.push(element);\n  }\n\n  // dequeue()\n  dequeue() {\n    // removing element from the queue\n    // returns underflow when called\n    // on empty queue\n    if (this.isEmpty()) return \"Underflow\";\n    return this.items.shift();\n  }\n\n  // front()\n  front() {\n    // returns the Front element of\n    // the queue without removing it.\n    if (this.isEmpty()) return \"No elements in Queue\";\n    return this.items[0];\n  }\n\n  // isEmpty()\n  isEmpty() {\n    // return true if the queue is empty.\n    return this.items.length === 0;\n  }\n\n  // printQueue()\n  printQueue() {\n    var str = \"\";\n    for (var i = 0; i < this.items.length; i++) str += this.items[i] + \" \";\n    return str;\n  }\n}\n","import { Queue } from \"./Queue\";\nimport { MinHeap } from \"../index\";\n\nexport class Graph {\n  constructor(noOfVertices) {\n    this.noOfVertices = noOfVertices;\n    this.AdjList = new Map();\n  }\n\n  addVertex(v) {\n    // initialize the adjacent list with a\n    // null array\n    this.AdjList.set(v, []);\n  }\n\n  addEdge(v, w) {\n    // get the list for vertex v and put the\n    // vertex w denoting edge between v and w\n    this.AdjList.get(v).push(w);\n\n    // Since graph is undirected,\n    // add an edge from w to v also\n    // this.AdjList.get(w).push(v);\n  }\n\n  printGraph() {\n    // get all the vertices\n    var get_keys = this.AdjList.keys();\n\n    // iterate over the vertices\n    for (var i of get_keys) {\n      // great the corresponding adjacency list\n      // for the vertex\n      var get_values = this.AdjList.get(i);\n      var conc = \"\";\n\n      // iterate over the adjacency list\n      // concatenate the values into a string\n      for (var j of get_values) conc += j + \" \";\n\n      // print the vertex and its adjacency list\n      console.log(i + \" -> \" + conc);\n    }\n  }\n\n  // bfs(v)\n  // function to performs BFS\n  bfs(startingNode) {\n    // create a visited array\n    const animations = [];\n\n    var visited = [];\n    for (var i = 0; i < this.noOfVertices; i++) visited[i] = false;\n\n    // Create an object for queue\n    var q = new Queue();\n\n    // add the starting node to the queue\n    visited[startingNode] = true;\n    q.enqueue(startingNode);\n\n    let dist = 1;\n    // loop until queue is element\n    while (!q.isEmpty()) {\n      // get the element from the queue\n      var getQueueElement = q.dequeue();\n\n      // passing the current vertex to callback funtion\n      // console.log(getQueueElement);\n\n      // get the adjacent list for current vertex\n      var get_List = this.AdjList.get(getQueueElement);\n\n      // loop through the list and add the element to the\n      // queue if it is not processed yet\n      for (var n in get_List) {\n        var neigh = get_List[n];\n\n        if (!visited[neigh]) {\n          neigh.predecessor = getQueueElement;\n          neigh.dist = dist;\n          animations.push(neigh);\n          visited[neigh] = true;\n          q.enqueue(neigh);\n        }\n      }\n      dist++;\n    }\n\n    return animations;\n  }\n\n  // dfs(v)\n  // Main DFS method\n  dfs(startingNode, withAnimation) {\n    const animations = [];\n\n    var visited = [];\n    for (var i = 0; i < this.noOfVertices; i++) visited[i] = false;\n\n    this.DFSUtil(startingNode, visited, animations);\n\n    return animations;\n  }\n\n  // Recursive function which process and explore\n  // all the adjacent vertex of the vertex with which it is called\n  DFSUtil(vert, visited, animations) {\n    visited[vert] = true;\n\n    var get_neighbours = this.AdjList.get(vert);\n\n    for (var i in get_neighbours) {\n      var get_elem = get_neighbours[i];\n      if (!visited[get_elem]) {\n        get_elem.predecessor = vert;\n        animations.push(get_elem);\n        this.DFSUtil(get_elem, visited, animations);\n      }\n    }\n  }\n\n  //dijkstra solve graph starting at s\n  dijkstra(startNode, animations, hasSecond) {\n    const heap = new MinHeap((item) => item.dist);\n\n    heap.push(startNode);\n\n    let finishedAnimating = false;\n\n    while (!heap.isEmpty()) {\n      //for each existing solution\n      const currentNode = heap.pop();\n\n      var currentdist = currentNode.dist;\n      var adj = this.AdjList.get(currentNode); // get neighbors\n\n      //for each of its adjacent nodes...\n      for (var a in adj) {\n        const adjacentNode = adj[a];\n\n        //choose nearest node with lowest *total* cost\n        var d = 1 + currentdist;\n\n        if (d < adjacentNode.dist && !heap.contains(adjacentNode)) {\n          if (!finishedAnimating) animations.push(adjacentNode);\n          heap.push(adjacentNode);\n          //reference parent\n          adjacentNode.predecessor = currentNode;\n          adjacentNode.dist = d;\n          if (adjacentNode.is(\"Target\") || adjacentNode.is(\"SecondaryTarget\"))\n            if (hasSecond) {\n              this.dijkstra(adjacentNode, animations);\n            } else {\n              finishedAnimating = true;\n            }\n        }\n      }\n    }\n    return animations;\n  }\n\n  aStar(startNode, targetNode, withAnimation) {\n    if(targetNode === null) return;\n    !withAnimation && console.log(\"NO ANIMATION\");\n    const animations = [];\n\n    const heap = new MinHeap((item) => item.f);\n    startNode.g = 0;\n    this.manhattanDistance(startNode, targetNode);\n\n    heap.push(startNode);\n\n    heap.print();\n\n    while (!heap.isEmpty()) {\n      console.log(heap);\n      const currentNode = heap.pop();\n\n      var currentdist = currentNode.dist;\n      var adj = this.AdjList.get(currentNode); // get neighbors\n      console.log(adj);\n      //for each of its adjacent nodes...\n      for (var a in adj) {\n        const adjacentNode = adj[a];\n\n        //choose nearest node with lowest *total* cost\n        var d = 1 + currentdist;\n\n        if (d < adjacentNode.dist && !heap.contains(adjacentNode)) {\n          if (!withAnimation) {\n            console.log(\"Got here\");\n            adjacentNode.markSearched2Done();\n          }\n          animations.push(adjacentNode);\n          this.manhattanDistance(adjacentNode, targetNode);\n          heap.push(adjacentNode);\n          //reference parent\n          adjacentNode.predecessor = currentNode;\n          adjacentNode.dist = d;\n          if (adjacentNode.is(\"Target\")) {\n            if (!withAnimation) adjacentNode.markShortestPath();\n            return animations;\n          }\n        }\n      }\n    }\n\n    return animations;\n  }\n\n  manhattanDistance(node, targetNode) {\n    const h =\n      Math.abs(node.col - targetNode.col) + Math.abs(node.row - targetNode.row);\n    node.h = h;\n    node.f = node.g + node.h;\n  }\n\n  bestFirstSearch(startNode, targetNode, withAnimation) {\n    if(targetNode === null) return;\n    const animations = [];\n\n    const heap = new MinHeap((item) => item.f);\n    startNode.g = 0;\n    this.euclideanDistance(startNode, targetNode);\n\n    heap.push(startNode);\n\n    heap.print();\n\n    while (!heap.isEmpty()) {\n      const currentNode = heap.pop();\n\n      var currentdist = currentNode.dist;\n      var adj = this.AdjList.get(currentNode); // get neighbors\n\n      //for each of its adjacent nodes...\n      for (var a in adj) {\n        const adjacentNode = adj[a];\n\n        //choose nearest node with lowest *total* cost\n        var d = 1 + currentdist;\n\n        if (d < adjacentNode.dist && !heap.contains(adjacentNode)) {\n          if (!withAnimation) adjacentNode.markSearched2Done();\n          animations.push(adjacentNode);\n\n          this.euclideanDistance(adjacentNode, targetNode);\n\n          heap.push(adjacentNode);\n\n          //reference parent\n          adjacentNode.predecessor = currentNode;\n          adjacentNode.dist = d;\n          if (adjacentNode.is(\"Target\")) {\n            if (!withAnimation) adjacentNode.markShortestPath();\n            return animations;\n          }\n        }\n      }\n    }\n\n    return animations;\n  }\n\n  euclideanDistance(node, targetNode) {\n    const h = Math.sqrt(\n      Math.pow(node.col - targetNode.col, 2) +\n        Math.pow(node.row - targetNode.row, 2)\n    );\n    node.h = Math.floor(h);\n    node.f = node.g + node.h;\n  }\n}\n","export class MinHeap {\n  constructor(selector) {\n    this.items = [];\n    this.selector = selector;\n  }\n\n  seek() {\n    return this.items[0];\n  }\n\n  push(item) {\n    let i = this.items.length;\n    this.items.push(item);\n\n    let parentIndex = Math.floor((i + 1) / 2 - 1);\n\n    if (parentIndex < 0) parentIndex = 0;\n\n    // console.log(\"ParentIndex\", parentIndex);\n\n    let parentVal = this.selector(this.items[parentIndex]);\n    const pushedVal = this.selector(this.items[i]);\n\n    // console.log(\"ParentVal, parentIndex:\", parentVal, parentIndex);\n    // console.log(\"PushedVal\", pushedVal);\n\n    while (i > 0 && parentVal > pushedVal) {\n      parentIndex = Math.floor((i + 1) / 2 - 1);\n      // console.log(\n      //   \"INSIDE LOOP ParentVal, parentIndex:\",\n      //   parentVal,\n      //   parentIndex\n      // );\n\n      this.swap(i, parentIndex);\n\n      i = parentIndex;\n      // console.log(\n      //   \"New INSIDE LOOP parentIndex:\",\n      //   Math.max(Math.floor((i + 1) / 2 - 1), 0)\n      // );\n\n      parentVal = this.selector(\n        this.items[Math.max(Math.floor((i + 1) / 2 - 1), 0)]\n      );\n    }\n\n    // this.print();\n  }\n\n  swap(i, j) {\n    let t = this.items[i];\n    this.items[i] = this.items[j];\n    this.items[j] = t;\n  }\n\n  pop() {\n    // console.log(\"Items before pop:\", this.items);\n    if (this.items.length <= 1) return this.items.pop(); //If it is the last element pop it\n    const ret = this.items[0]; // What we will return\n    let temp = this.items.pop();\n    this.items[0] = temp; // Place last element in array at front\n\n    // console.log(\"Items after pop:\", this.items); // Good till here\n    let i = 0; // We adjust heap from top to down\n\n    while (true) {\n      let rightChildIndex = (i + 1) * 2;\n      let leftChildIndex = (i + 1) * 2 - 1;\n\n      // console.log(\"rightIndex\", rightChildIndex);\n      // console.log(\"rightValue\", this.items[rightChildIndex]);\n      // console.log(\"leftIndex\", leftChildIndex);\n      // console.log(\"leftValue\", this.items[leftChildIndex]);\n      let lowest = rightChildIndex;\n\n      if (\n        leftChildIndex >= this.items.length &&\n        rightChildIndex >= this.items.length\n      )\n        break;\n      if (leftChildIndex >= this.items.length) lowest = rightChildIndex;\n      if (rightChildIndex >= this.items.length) lowest = leftChildIndex;\n\n      if (\n        !(leftChildIndex >= this.items.length) &&\n        !(rightChildIndex >= this.items.length)\n      ) {\n        lowest =\n          this.selector(this.items[rightChildIndex]) <\n          this.selector(this.items[leftChildIndex])\n            ? rightChildIndex\n            : leftChildIndex;\n      } // Find the smallest child\n\n      // If the parent is greater than the smallest child: swap\n      if (this.selector(this.items[i]) > this.selector(this.items[lowest])) {\n        this.swap(i, lowest);\n        i = lowest;\n      } else break; // We have finished setting up the heap\n    }\n\n    // Return topmost element\n    return ret;\n  }\n\n  contains(item) {\n    return this.items.includes(item);\n  }\n\n  isEmpty() {\n    return this.items.length === 0;\n  }\n\n  delete(item) {\n    let i = this.items.indexOf(item);\n    // heapify\n    this.items[i] = this.items.pop();\n    while (true) {\n      let lowest =\n        this.selector(this.items[(i + 1) * 2]) <\n        this.selector(this.items[(i + 1) * 2 - 1])\n          ? (i + 1) * 2\n          : (i + 1) * 2 - 1;\n      if (this.selector(this.items[i]) > this.selector(this.items[lowest])) {\n        let t = this.items[i];\n        this.items[i] = this.items[lowest];\n        this.items[lowest] = t;\n        i = lowest;\n      } else break;\n    }\n  }\n\n  print() {\n    for (let i = 0; i < this.items.length; i++) {\n      console.log(this.items[i]);\n    }\n  }\n\n  heapify(arr) {\n    for (let i = 0; i < arr.length; i++) {\n      this.push(arr[i]);\n    }\n  }\n}\n\n// const heap = new MinHeap((x) => x.dist);\n// heap.heapify([6, 3, 6, 9, 43, 0, 8, 0, 8]);\n// console.log(heap);\n// console.log(heap.isEmpty());\n\n// heap.heapify([1, 2, 7, 4, 8, 0, 4, 2, 7, 3]);\n\n// heap.heapify([\n//   { dist: 1 },\n//   { dist: 2 },\n//   { dist: 7 },\n//   { dist: 4 },\n//   { dist: 8 },\n//   { dist: 0 },\n//   { dist: 4 },\n//   { dist: 2 },\n//   { dist: 7 },\n//   { dist: 3 },\n// ]);\n\n// heap.heapify([\n//   { dist: 1 },\n//   { dist: 2 },\n//   { dist: 7 },\n//   { dist: 4 },\n//   { dist: 8 },\n//   { dist: 0 },\n//   { dist: 4 },\n//   { dist: 2 },\n//   { dist: 7 },\n//   { dist: 3 },\n//   { dist: 23 },\n//   { dist: 200 },\n//   { dist: -1 },\n// ]);\n\n// heap.print();\n// // const a = heap.pop()\n// // heap.pop()\n// // heap.pop()\n\n// console.log(heap.items);\n\n// while (!heap.isEmpty()) {\n//   // console.log(\"Length\", heap.items.length);\n//   const a = heap.pop();\n//   console.log(\"Value:\", a);\n//   // console.log(\"Length\", heap.items.length);\n// }\n","export const DIJKSTRA = \"Dijkstra\"\nexport const ASTAR = \"A*\"\nexport const GREEDY_BFS = \"Greedy Best First Search\"\nexport const BFS = \"Breadth First Search\"\nexport const DFS = \"Depth First Search\"\n\nexport const RAND_MAZE = \"Random Maze\"\nexport const RECURSIVE_DIVISON = \"Recursive Division\"\nexport const DRAW_COUNTOUR = \"Contour Walls\"\n","export default class Node {\n  constructor(row, col) {\n    this.row = row;\n    this.col = col;\n    this.predecessor = null;\n    this.dist = Infinity;\n    this.g = 1;\n    this.h = null;\n    this.f = null;\n  }\n\n  removeClass(s) {\n    this.classes.remove(s);\n  }\n\n  setClasses() {\n    this.cell = document.getElementById(`${this.row} ${this.col}`);\n    this.classes = this.cell.classList;\n  }\n\n  toString() {\n    return \"(\" + this.row + \" \" + this.col + \")\";\n  }\n\n  setWall() {\n    if (this.isKeyValue()) return;\n    this.classes.add(\"Wall\");\n  }\n\n  setAsTarget() {\n    this.classes.add(\"Target\");\n    this.markShortestPath();\n  }\n\n  setAsSecondTarget() {\n    this.classes.remove(\"Wall\");\n    this.classes.add(\"SecondaryTarget\");\n  }\n\n  markSearched() {\n    if (this.is(\"Target\")) return;\n    this.classes.add(\"Searched\");\n  }\n\n  markSearched2() {\n    if (this.is(\"Target\")) return;\n    this.classes.add(\"Searched2\");\n  }\n\n  markSearched2Done() {\n    if (this.is(\"Target\") || this.is(\"Start\")) return;\n    this.classes.add(\"Searched2Done\");\n  }\n\n  removeVisuals() {\n    this.remove([\"ShortestPath\", \"Searched\", \"Searched2\", \"Searched2Done\"]);\n    this.predecessor = null;\n    this.dist = Infinity;\n  }\n\n  removeClasses() {\n    this.classes.forEach(\n      (item) => item !== \"Cell\" && item !== \"Wall\" && this.classes.remove(item)\n    );\n  }\n\n  reset() {\n    this.remove([\"ShortestPath\", \"Wall\", \"Searched\"]);\n    this.remove([\"Searched2\", \"SecondaryTarget\", \"Searched2Done\"]);\n    this.predecessor = null;\n    this.dist = Infinity;\n  }\n\n  isKeyValue() {\n    return this.is(\"Target\") || this.is(\"Start\") || this.is(\"SecondaryTarget\");\n  }\n\n  markShortestPath() {\n    if (!this.is(\"Target\") && !this.is(\"Start\")) {\n      this.remove([\"Searched\", \"Searched2\", \"Searched2Done\"]);\n      this.classes.add(\"ShortestPath\");\n    }\n    if (this.predecessor != null) {\n      this.predecessor.markShortestPath();\n    }\n  }\n\n  remove(classes) {\n    for (let i in classes) this.classes.remove(classes[i]);\n  }\n\n  is(name) {\n    return this.classes.contains(name);\n  }\n\n  add(name) {\n    this.classes.add(name);\n  }\n}\n","import { useRef } from \"react\";\nimport Node from \"../utility/Node\";\n\nconst generateNodeGrid = (numRows, numCols) => {\n  const nodesGrid = [];\n\n  for (let row = 0; row < numRows; row++) {\n    nodesGrid[row] = [];\n    for (let col = 0; col < numCols; col++) {\n      const newNode = new Node(row, col);\n      nodesGrid[row][col] = newNode;\n    }\n  }\n\n  return nodesGrid;\n};\n\nconst useNodeGrid = () => {\n  const nodesGrid = generateNodeGrid(20, 50);\n  const nodeGridRef = useRef(nodesGrid);\n  const nodeGrid = nodeGridRef.current;\n\n  const resetGrid = () => {\n    for (let row in nodeGrid) {\n      for (let col in nodeGrid[row]) {\n        nodeGrid[row][col].reset();\n      }\n    }\n  };\n\n  const removeVisuals = () => {\n    for (let row in nodeGrid) {\n      for (let col in nodeGrid[row]) {\n        nodeGrid[row][col].removeVisuals();\n      }\n    }\n  };\n\n  const paintInDistance = (dist) => {\n    if (dist === Infinity) return;\n    for (let row in nodeGrid) {\n      for (let col in nodeGrid[row]) {\n        if (nodeGrid[row][col].dist <= dist) {\n          nodeGrid[row][col].markSearched2Done();\n        } else {\n          nodeGrid[row][col].removeClasses();\n        }\n      }\n    }\n  };\n\n  const resetDistance = () => {\n    for (let row in nodeGrid) {\n      for (let col in nodeGrid[row]) {\n        nodeGrid[row][col].dist = Infinity;\n        if (!nodeGrid[row][col].isKeyValue()) {\n          nodeGrid[row][col].removeClasses();\n        }\n      }\n    }\n  };\n\n  return { nodeGrid, resetGrid, removeVisuals, paintInDistance, resetDistance };\n};\n\nexport default useNodeGrid;\n","import React from \"react\";\nimport classes from \"./NavigationItem.module.css\";\n\nconst NavigationItem = ({ children, clicked }) => (\n  <div className={classes.NavigationItem}>\n    <button onClick={clicked} className={classes.Btn}>\n      {children}\n    </button>\n  </div>\n);\nexport default NavigationItem;\n","import React from \"react\";\nimport \"./DropDown.css\";\n\nconst DropDown = ({ children, clicked, moreInfo, title }) => {\n  return (\n    <div className=\"dropdown\">\n      <button className=\"dropbtn\">\n        {title}\n      </button>\n      <div className=\"dropdown-content\">\n        {children}\n      </div>\n    </div>\n  );\n};\n\nexport default DropDown;\n","import React from \"react\";\nimport \"./Subnav.css\";\n\nconst Subnav = ({ children, title }) => {\n  return (\n    <div className=\"subnav\">\n      <button className=\"subnavbtn\">{title}</button>\n      <div className=\"subnav-content\">{children}</div>\n    </div>\n  );\n};\n\nexport default Subnav;\n","import React from \"react\";\n\nconst DropItem = ({children, clicked}) => {\nreturn <p onClick={clicked}>{children}</p>;\n};\n\nexport default DropItem;\n","import React from \"react\";\nimport NavigationItem from \"./NavigationItem/NavigationItem\";\nimport * as cts from \"../../../utility\";\nimport DropDown from \"./Dropdown/DropDown\";\nimport Subnav from \"./Subnav/Subnav\";\nimport DropItem from \"./Dropdown/DropItem/DropItem\";\n\nconst NavigationItems = ({\n  setAlgorithm,\n  reset,\n  executeAlgorithm,\n  algorithm,\n  mazeGen,\n  settingSecondTarget,\n  openDialog,\n  clear,\n  setDeleting\n}) => (\n  <>\n    <NavigationItem clicked={openDialog}>GRAPH ALGORITHMS</NavigationItem>\n    <Subnav title=\"Algorithms\">\n      <DropDown title={cts.DIJKSTRA}>\n        <DropItem clicked={() => setAlgorithm(cts.DIJKSTRA)}>Select</DropItem>\n        <DropItem clicked={() => alert(cts.DIJKSTRA)}>Learn More</DropItem>\n      </DropDown>\n      <DropDown\n        clicked={() => setAlgorithm(cts.ASTAR)}\n        moreInfo={() => alert(cts.ASTAR)}\n        title={cts.ASTAR}\n      >\n        <DropItem clicked={() => setAlgorithm(cts.ASTAR)}>Select</DropItem>\n        <DropItem clicked={() => alert(cts.ASTAR)}>Learn More</DropItem>\n      </DropDown>\n      <DropDown\n        clicked={() => setAlgorithm(cts.GREEDY_BFS)}\n        moreInfo={() => alert(cts.GREEDY_BFS)}\n        title={cts.GREEDY_BFS}\n      >\n        <DropItem clicked={() => setAlgorithm(cts.GREEDY_BFS)}>Select</DropItem>\n        <DropItem clicked={() => alert(cts.GREEDY_BFS)}>Learn More</DropItem>\n      </DropDown>\n      <DropDown title={cts.BFS}>\n        <DropItem clicked={() => setAlgorithm(cts.BFS)}>Select</DropItem>\n        <DropItem clicked={() => alert(cts.BFS)}>Learn More</DropItem>\n      </DropDown>\n      <DropDown title={cts.DFS}>\n        <DropItem clicked={() => setAlgorithm(cts.DFS)}>Select</DropItem>\n        <DropItem clicked={() => alert(cts.DFS)}>Learn More</DropItem>\n      </DropDown>\n    </Subnav>\n    <Subnav title=\"Maze Generators\">\n      <DropDown\n        title={cts.RAND_MAZE}\n        clicked={() => mazeGen(cts.RAND_MAZE)}\n        moreInfo={() => alert(cts.DIJKSTRA)}\n      >\n        <DropItem clicked={() => mazeGen(cts.RAND_MAZE)}>Generate</DropItem>\n        <DropItem clicked={() => alert(cts.RECURSIVE_DIVISON)}>\n          Learn More\n        </DropItem>\n      </DropDown>\n      <DropDown title={cts.RECURSIVE_DIVISON}>\n        <DropItem clicked={() => mazeGen(cts.RECURSIVE_DIVISON)}>\n          Generate\n        </DropItem>\n        <DropItem clicked={() => alert(cts.RECURSIVE_DIVISON)}>\n          Learn More\n        </DropItem>\n      </DropDown>\n      <DropDown title={cts.DRAW_COUNTOUR}>\n        <DropItem clicked={() => mazeGen(cts.DRAW_COUNTOUR)}>\n          Generate\n        </DropItem>\n        <DropItem clicked={() => alert(cts.DRAW_COUNTOUR)}>\n          Learn More\n        </DropItem>\n      </DropDown>\n    </Subnav>\n    <Subnav title=\"Draw\">\n    <DropDown title=\"Options\">\n        <DropItem clicked={() => setDeleting(true)}>\n          Delete Wall\n        </DropItem>\n        <DropItem clicked={() => setDeleting(false)}>\n          Draw Wall\n        </DropItem>\n      </DropDown>\n    </Subnav>\n   \n    <NavigationItem clicked={() => settingSecondTarget(true)}>Add Second Target</NavigationItem>\n    <NavigationItem clicked={reset}>Reset</NavigationItem>\n    <NavigationItem clicked={clear}>Clear Visualization</NavigationItem>\n    <NavigationItem clicked={executeAlgorithm}>\n      Visualize {algorithm}!\n    </NavigationItem>\n  </>\n);\nexport default NavigationItems;\n","import React from \"react\";\nimport classes from \"./Toolbar.module.css\";\nimport NavigationItems from \"../NavigationItems/NavigationItems\";\n\nconst toolbar = (props) => {\n  return (\n    <header className={classes.Toolbar}>\n        <NavigationItems {...props} />\n    </header>\n  );\n};\nexport default toolbar;\n","import React, { useState } from \"react\";\nimport Cell from \"./Cell\";\nimport * as util from \"../utility/index\";\nimport \"./Board.css\";\nimport useNodeGrid from \"../hooks/useNodeGrid\";\nimport Navbar from \"./Navigation/Toolbar/Toolbar\";\n\nconst ROWS_INIT = 20;\nconst COLS_INIT = 50;\n\nconst Board = ({ openDialog }) => {\n  const [algorithm, setAlgorithm] = useState(util.DIJKSTRA);\n  const {\n    nodeGrid,\n    resetGrid,\n    removeVisuals,\n    paintInDistance,\n    resetDistance,\n  } = useNodeGrid();\n  const [isMouseDown, setIsMouseDown] = useState(false);\n  const [animating, setIsAnimating] = useState(true);\n  const [isMovingTarget, setIsMovingTarget] = useState(false);\n  const [isMovingSecondTarget, setIsMovingSecondTarget] = useState(false);\n  const [isMovingStart, setIsMovingStart] = useState(false);\n  const [settingSecondTarget, setSettingSecondTarget] = useState(false);\n  const [hasSecondTarget, setHasSecondTarget] = useState(false);\n  const [numTargets, setNumTargets] = useState(1);\n  const [prevAlgorithm, setPrevAlgorithm] = useState(util.DIJKSTRA);\n  const [canPlaceWall, setCanPlaceWall] = useState(true);\n  const [isDeleting, setIsDeleting] = useState(false);\n\n  const handleTargetMove = (node) => {\n    node.setAsTarget();\n    switch (prevAlgorithm) {\n      case util.DIJKSTRA:\n        paintInDistance(node.dist);\n        node.markShortestPath();\n        break;\n      case util.ASTAR:\n        resetDistance();\n        AStar(false);\n        break;\n      case util.GREEDY_BFS:\n        resetDistance();\n        bestFirstSearch(false);\n        break;\n      case util.BFS:\n        paintInDistance(node.dist);\n        node.markShortestPath();\n        break;\n      case util.DFS:\n        resetDistance();\n        DFS(false);\n        node.markShortestPath();\n        break;\n      default:\n    }\n  };\n\n  const onMouseEnterHandler = (node) => {\n    if (!animating) return;\n    if (settingSecondTarget) {\n      node.setAsSecondTarget();\n    }\n    if (\n      isMouseDown &&\n      !isMovingStart &&\n      !isMovingTarget &&\n      !isMovingSecondTarget\n    ) {\n      if (canPlaceWall) node.setWall();\n    }\n    if (isMouseDown && isMovingStart && !node.is(\"Target\")) node.add(\"Start\");\n    if (isMouseDown && isMovingTarget && !node.is(\"Start\")) {\n      handleTargetMove(node);\n    }\n    if (isMouseDown && isMovingSecondTarget) node.setAsSecondTarget();\n  };\n\n  const onMouseDownHandler = (node) => {\n    if (!animating) return;\n    if (isDeleting) return node.remove([\"Wall\"]);\n    setIsMouseDown(true);\n    if (settingSecondTarget) {\n      let num = numTargets;\n      setNumTargets(num + 1);\n      setHasSecondTarget(true);\n      return setSettingSecondTarget(false);\n    }\n    if (!node.isKeyValue() && canPlaceWall) return node.setWall();\n    if (node.is(\"Start\") && canPlaceWall) return setIsMovingStart(true);\n    if (node.is(\"Target\")) return setIsMovingTarget(true);\n    if (node.is(\"SecondaryTarget\")) return setIsMovingSecondTarget(true);\n  };\n\n  const onMouseLeaveHandler = (node) => {\n    if (!animating) return;\n    if (\n      isMovingStart ||\n      isMovingTarget ||\n      settingSecondTarget ||\n      isMovingSecondTarget\n    ) {\n      if (isMovingStart) node.removeClass(\"Start\");\n      if (isMovingTarget) node.removeClass(\"Target\");\n    }\n  };\n\n  const onMouseUpHandler = () => {\n    if (!animating) return;\n    setIsMouseDown(false);\n    setIsMovingStart(false);\n    setIsMovingTarget(false);\n    setIsMovingSecondTarget(false);\n  };\n\n  let Grid = nodeGrid.map((row, rowNum) => {\n    return row.map((val, colNum) => {\n      return (\n        <Cell\n          key={val}\n          node={nodeGrid[rowNum][colNum]}\n          onMouseEnter={onMouseEnterHandler}\n          onMouseDown={onMouseDownHandler}\n          onMouseUp={onMouseUpHandler}\n          onMouseLeave={onMouseLeaveHandler}\n        />\n      );\n    });\n  });\n\n  const executeAlgorithm = (type) => {\n    removeVisualization();\n    if (!animating) return;\n    setIsAnimating(false);\n    setPrevAlgorithm(algorithm);\n    setCanPlaceWall(false);\n\n    let animations = [];\n    switch (algorithm) {\n      case util.BFS:\n        animations = BFS();\n        break;\n      case util.DFS:\n        animations = DFS(true);\n        break;\n      case util.ASTAR:\n        animations = AStar(true);\n        break;\n      case util.DIJKSTRA:\n        animations = Dijkstra();\n        break;\n      case util.GREEDY_BFS:\n        animations = bestFirstSearch(true);\n        break;\n      default:\n        animations = BFS();\n        break;\n    }\n    animate(animations);\n  };\n\n  const BFS = () => {\n    const { startNode, graph } = util.generateGraph(nodeGrid);\n    const animations = graph.bfs(startNode);\n    return animations;\n  };\n\n  const DFS = (withAnimation) => {\n    const { startNode, graph } = util.generateGraph(nodeGrid);\n    const animations = graph.dfs(startNode, withAnimation);\n    return animations;\n  };\n\n  const Dijkstra = () => {\n    const { startNode, graph } = util.generateGraph(nodeGrid);\n    const animations = [];\n    graph.dijkstra(startNode, animations, hasSecondTarget);\n    return animations;\n  };\n\n  const AStar = (withAnimation) => {\n    const { startNode, graph, targetNode } = util.generateGraph(nodeGrid);\n    const animations = graph.aStar(startNode, targetNode, withAnimation);\n    return animations;\n  };\n\n  const bestFirstSearch = (withAnimation) => {\n    const { startNode, graph, targetNode } = util.generateGraph(nodeGrid);\n    const animations = graph.bestFirstSearch(\n      startNode,\n      targetNode,\n      withAnimation\n    );\n    return animations;\n  };\n\n  const clear = () => {\n    if (!animating) return;\n    setCanPlaceWall(true);\n    setHasSecondTarget(false);\n    setPrevAlgorithm(null);\n    resetGrid();\n  };\n\n  const removeVisualization = () => {\n    if (!animating) return;\n    setCanPlaceWall(true);\n    setPrevAlgorithm(null);\n    removeVisuals();\n  };\n\n  const generateMaze = (type) => {\n    if (!animating) return;\n    clear();\n\n    switch (type) {\n      case util.RECURSIVE_DIVISON:\n        util.recursiveDivision(nodeGrid);\n        break;\n      case util.DRAW_COUNTOUR:\n        util.drawContourWalls(nodeGrid);\n        break;\n      default:\n        util.randomMaze(nodeGrid);\n        break;\n    }\n  };\n\n  const animate = (animations) => {\n    if (animations.length <= 0) {\n      setIsAnimating(true);\n      return;\n    }\n    let count = 0;\n    let targetNum = 1;\n\n    const intervalId = setInterval(() => {\n      const node = animations[count];\n\n      targetNum % 2 === 0 ? node.markSearched() : node.markSearched2();\n\n      (node.is(\"Target\") || node.is(\"SecondaryTarget\")) &&\n        node.markShortestPath();\n\n      count++;\n\n      if (count >= animations.length) {\n        setIsAnimating(true);\n        clearInterval(intervalId);\n      }\n    }, 10);\n  };\n\n  return (\n    <div className=\"MainContainer\">\n      <Navbar\n        setDeleting={setIsDeleting}\n        openDialog={openDialog}\n        setAlgorithm={setAlgorithm}\n        reset={clear}\n        algorithm={algorithm}\n        executeAlgorithm={executeAlgorithm}\n        clear={removeVisualization}\n        mazeGen={generateMaze}\n        settingSecondTarget={setSettingSecondTarget}\n      />\n      <br />\n      <div\n        className=\"Board\"\n        style={{\n          gridTemplateRows: `repeat(${ROWS_INIT}, 1fr)`,\n          gridTemplateColumns: `repeat(${COLS_INIT}, 1fr)`,\n        }}\n      >\n        {Grid}\n      </div>\n    </div>\n  );\n};\n\nexport default Board;\n","export const randomMaze = (board) => {\n  for (let row in board) {\n    for (let col in board[row]) {\n      Math.random() <= 0.3 && board[row][col].setWall();\n    }\n  }\n};\n","import React from \"react\";\nimport \"./Backdrop.css\";\n\nconst backdrop = (props) => {\n  const cssClasses = [\n    \"Backdrop\",\n    props.show ? \"BackdropOpen\" : \"BackdropClosed\",\n  ];\n  return <div className={cssClasses.join(\" \")}></div>;\n};\n\nexport default backdrop;\n","import React from \"react\";\nimport {\n  Button,\n  Dialog,\n  DialogActions,\n  DialogContent,\n  DialogContentText,\n  DialogTitle,\n} from \"@material-ui/core\";\nimport PropTypes from \"prop-types\";\nimport Backdrop from \"../Backdrop/Backdrop\";\n\nexport const CustomDialog = ({\n  isOpen,\n  handleClose,\n  title,\n  subtitle,\n  children,\n  howToPlay,\n}) => {\n  return (\n    <>\n      <Dialog\n        fullWidth\n        maxWidth=\"md\"\n        open={isOpen}\n        onClose={handleClose}\n        aria-labelledby=\"max-width-dialog-title\"\n      >\n        <DialogTitle id=\"max-width-dialog-title\">{title}</DialogTitle>\n        <DialogContent>\n          <DialogContentText>{subtitle}</DialogContentText>\n          {children}\n        </DialogContent>\n        <DialogActions>\n          <Button onClick={handleClose} color=\"secondary\">\n            Close\n          </Button>\n        </DialogActions>\n      </Dialog>\n      <Backdrop show={isOpen} />\n    </>\n  );\n};\n\nCustomDialog.propTypes = {\n  isOpen: PropTypes.bool.isRequired,\n  handleClose: PropTypes.func.isRequired,\n  title: PropTypes.string.isRequired,\n  subtitle: PropTypes.string,\n  children: PropTypes.element.isRequired,\n};\n","import React, { useState, useEffect } from \"react\";\nimport Board from \"./components/Board\";\nimport { CustomDialog } from \"./components/UI/CustomDialog/CustomDialog\";\nimport Paper from \"@material-ui/core/Paper\";\nimport classes from \"./App.module.css\";\n\nfunction App() {\n  const [isOpen, setIsOpen] = useState(true);\n  useEffect(() => {\n    handleDialogOpen();\n  }, []);\n\n  const handleDialogOpen = () => {\n    setIsOpen(true);\n  };\n\n  const handleDialogClose = () => {\n    setIsOpen(false);\n  };\n  return (\n    <div className={classes.App}>\n      <Board openDialog={handleDialogOpen}/>\n      <CustomDialog\n        title=\"Welcome\"\n        isOpen={isOpen}\n        handleClose={handleDialogClose}\n        className={classes.customDialog}\n      >\n        <Paper>\n          <h1>Welcome to The Graph Algorithms Visualizer!</h1>\n          <br />\n          <h4>\n            This Project Helps CS Enthusiasts visualize popular graph\n            traversal/pathfinding algorithms. To get Started, click on an\n            algorithm located on the header and press Visualize!.\n          </h4>\n          <p>For a better Experience, Use use browser to full width</p>\n        </Paper>\n      </CustomDialog>\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}