{"version":3,"sources":["hooks/useGrid.js","components/Cell.js","utility/GraphAlgorithms/BFS.js","utility/GraphAlgorithms/DFS.js","utility/helper.js","utility/GraphAlgorithms/Dijkstra.js","components/Board.js","utility/MazeGenerators/Random.js","App.js","index.js"],"names":["useGrid","numRows","numCols","startRow","startCol","initialRow","initialCol","targetRow","Math","floor","targetCol","useState","arr","row","col","createGrid","grid","setGrid","initialCoords","setInitialCoords","targetCoords","setTargetCoords","setCoord","val","newGrid","resetGrid","cell","document","getElementById","classList","contains","React","memo","isMouseDown","isMovingKeyItem","setIsMovingKeyItem","animationComplete","predecessors","drawShortestPath","classes","push","className","join","id","onMouseDown","onMouseEnter","add","onMouseLeave","remove","onMouseUp","prevState","nextState","bfs","a","queue","distance","predecesor","count","neighbors","generateAdjList","animations","length","item","shift","adjacent","i","dfs","stack","pop","getNeighbors","neighborsGrid","cellNotInGraph","list","rowNum","colNum","generateNeighborsGrid","clone","board","slice","dijkstra","START_ROW","ROWS_INIT","START_COL","colStart","rowStart","nextObj","currentCol","currentRow","Board","setIsMouseDown","setAnimationComplete","setPredecessors","Grid","map","key","doSearch","type","intervalId","setInterval","clearInterval","console","log","style","margin","Button","onClick","random","randomMaze","draggable","App","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.3d92d86e.chunk.js","sourcesContent":["import { useState } from \"react\";\n\nconst createGrid = (numRows, numCols, startRow, startCol) => {\n  let arr = [];\n  for (let row = 0; row < numRows; row++) {\n    arr[row] = [];\n    for (let col = 0; col < numCols; col++) {\n      arr[row][col] = \" \";\n    }\n  }\n  arr[startRow][startCol] = \"s\";\n  arr[Math.floor(numRows / 2)][Math.floor((numCols * 2) / 3)] = \"t\";\n  return arr;\n};\n\nconst useGrid = (numRows, numCols, startRow, startCol) => {\n  let initialRow = startRow;\n  let initialCol = startCol;\n  let targetRow = Math.floor(numRows / 2);\n  let targetCol = Math.floor((numCols * 2) / 3);\n\n  const [grid, setGrid] = useState(\n    createGrid(numRows, numCols, initialRow, initialCol)\n  );\n  const [initialCoords, setInitialCoords] = useState({\n    startRow,\n    startCol,\n  });\n  const [targetCoords, setTargetCoords] = useState({\n    targetRow,\n    targetCol,\n  });\n\n  const setCoord = (row, col, val) => {\n    let newGrid = [...grid];\n    if (val === \"s\") {\n      setInitialCoords({ startRow: row, startCol: col });\n    }\n    if (val === \"t\") {\n      setTargetCoords({ targetRow: row, targetCol: col });\n    }\n    newGrid[row][col] = val;\n    setGrid(newGrid);\n  };\n\n  const resetGrid = (numRows, numCols) => {\n    for (let row = 0; row < numRows; row++) {\n      for (let col = 0; col < numCols; col++) {\n        const cell = document.getElementById(`${row} ${col}`);\n        if(!cell.classList.contains(\"Target\") && !cell.classList.contains(\"Filled\")){\n          cell.classList = [\"Cell\"]\n        }\n       \n      }\n    }\n  };\n\n  return { grid, setGrid, setCoord, resetGrid, initialCoords, targetCoords };\n};\n\nexport default useGrid;\n","import React from \"react\";\nimport \"./Cell.css\";\n\nconst Cell = ({\n  val,\n  row,\n  col,\n  isMouseDown,\n  isMovingKeyItem,\n  setIsMovingKeyItem,\n  setCoord,\n  animationComplete,\n  predecessors,\n  drawShortestPath,\n}) => {\n  let classes = [\"Cell\"];\n  val === \"s\" && classes.push(\"Filled\");\n  val === \"t\" && classes.push(\"Target\");\n\n  const onMoveHandler = () => {\n    const cell = document.getElementById(`${row} ${col}`);\n    if (isMouseDown && !isMovingKeyItem[0]) {\n      cell.classList.add(\"Wall\");\n    }\n    if (isMovingKeyItem[0] && !animationComplete) {\n      if(isMovingKeyItem[1] === \"t\"){\n        cell.classList.add(\"Target\")\n      }else{\n        cell.classList.add(\"Filled\")\n      }\n    }\n    if(isMovingKeyItem[0] && animationComplete){\n      drawShortestPath(row, col, predecessors, 0, 0)\n    }\n  };\n\n  const onLeaveHandler = () => {\n    const cell = document.getElementById(`${row} ${col}`);\n    if (isMouseDown && isMovingKeyItem[0]) {\n      if(isMovingKeyItem[1] === \"t\"){\n        cell.classList.remove(\"Target\")\n      }else{\n        cell.classList.remove(\"Filled\")\n      }\n    }\n  }\n\n  const onClickHandler = () => {\n    if (val === \"t\" || val === \"s\") {\n      \n      setIsMovingKeyItem([true, val]);\n    }\n  };\n\n  const onMouseUpHandler = () => {\n    if(isMovingKeyItem[1]){\n      // Set coord and set IsNotmoving key item\n      setCoord(row, col, isMovingKeyItem[1])\n      setIsMovingKeyItem(false);\n    }\n  }\n\n  return (\n    <td\n      className={classes.join(\" \")}\n      id={`${row} ${col}`}\n      onMouseDown={onClickHandler}\n      onMouseEnter={onMoveHandler}\n      onMouseLeave={onLeaveHandler}\n      onMouseUp={onMouseUpHandler}\n    ></td>\n  );\n};\n\nconst compare = (prevState, nextState) => {\n  return (\n    prevState.val === nextState.val &&\n    prevState.isMouseDown === nextState.isMouseDown\n  );\n};\n\nexport default React.memo(Cell, compare);\n","import { generateAdjList } from \"../index\";\n\n// BFS\n// 1. Set all nodes distance and predecessor equal to null EXCEPT the source\n// which we will set the distance to 0\n// 2. Add the source to the queue\n// 3. While the Queue is not Empty\n// 4. Get the next Item in the queue\n// 5. Loop thru all its neighbors if we have not isited the node set its distance and predecesor\n// and add it to the queue\n\nexport const bfs = async (grid, startRow, startCol) => {\n  const queue = [];\n  queue.push({\n    row: startRow,\n    col: startCol,\n    distance: 0,\n    predecesor: {\n      row: startRow,\n      col: startCol,\n    },\n  });\n  let count = 1;\n  const neighbors = generateAdjList(grid);\n  const animations = [];\n  const predecessors = [...grid];\n\n  while (queue.length !== 0) {\n    let item = queue.shift();\n    const adjacent = neighbors[item.row][item.col];\n    for (let i = 0; i < adjacent.length; i++) {\n      if (adjacent[i].distance === null) {\n        animations.push({ row: adjacent[i].row, col: adjacent[i].col });\n        adjacent[i].distance = count;\n        adjacent[i].predecesor = { row: item.row, col: item.col };\n        predecessors[adjacent[i].row][adjacent[i].col] = ({ row: item.row, col: item.col });\n        queue.push(adjacent[i]);\n      }\n    }\n    count++;\n  }\n  return { animations, predecessors };\n};\n","import { generateAdjList } from \"../index\";\n// DFS\n// 1. Set all nodes distance and predecessor equal to null EXCEPT the source\n// which we will set the distance to 0\n// 2. Add the source to the stack\n// 3. While the stack is not Empty\n// 4. Get the next Item in the stack\n// 5. Loop thru all its neighbors if we have not isited the node set its distance and predecesor\n// and add it to the stack\n\nexport const dfs = async (grid, startRow, startCol) => {\n  const stack = [];\n  stack.push({\n    row: startRow,\n    col: startCol,\n    distance: 0,\n    predecesor: {\n      row: startRow,\n      col: startCol,\n    },\n  });\n  let count = 1;\n  const neighbors = generateAdjList(grid);\n  const animations = [];\n  const predecessors = [...grid];\n\n  while (stack.length !== 0) {\n    let item = stack.pop();\n    const adjacent = neighbors[item.row][item.col];\n    for (let i = 0; i < adjacent.length; i++) {\n      if (adjacent[i].distance === null) {\n        animations.push({ row: adjacent[i].row, col: adjacent[i].col });\n        adjacent[i].distance = count;\n        adjacent[i].predecesor = { row: item.row, col: item.col };\n        predecessors[adjacent[i].row][adjacent[i].col] = {\n          row: item.row,\n          col: item.col,\n        };\n        stack.push(adjacent[i]);\n      }\n    }\n    count++;\n  }\n  return { animations, predecessors };\n};\n","const generateNeighborsGrid = (rowNum, colNum) => {\n  let arr = [];\n  for (let row = 0; row < rowNum; row++) {\n    arr[row] = [];\n    for (let col = 0; col < colNum; col++) {\n      arr[row][col] = {\n        row,\n        col,\n        distance: null,\n        predecesor: null,\n      };\n    }\n  }\n  return arr;\n};\n\nconst getNeighbors = (grid, row, col, neighborsGrid) => {\n  const cellNotInGraph = (row, col) => {\n    const cellClasses = document.getElementById(`${row} ${col}`).classList;\n    return cellClasses.contains(\"Wall\") \n  };\n  if (cellNotInGraph(row, col)) return [];\n  let neighbors = [];\n\n  if (row > 0 && !cellNotInGraph(row - 1, col)) {\n    // N\n    neighbors.push(neighborsGrid[row - 1][col]);\n  }\n  if (col > 0 && !cellNotInGraph(row, col - 1)) {\n    // W\n    neighbors.push(neighborsGrid[row][col - 1]);\n  }\n  if (row < grid.length - 1 && !cellNotInGraph(row + 1, col)) {\n    // S\n    neighbors.push(neighborsGrid[row + 1][col]);\n  }\n  if (col < grid[row].length - 1 && !cellNotInGraph(row, col + 1)) {\n    // E\n    neighbors.push(neighborsGrid[row][col + 1]);\n  }\n\n  return neighbors;\n};\n\nexport const generateAdjList = (grid) => {\n  let list = [];\n  let neighborsGrid = generateNeighborsGrid(grid.length, grid[0].length);\n  for (let row = 0; row < grid.length; row++) {\n    list[row] = [];\n    for (let col = 0; col < grid[row].length; col++) {\n      list[row][col] = getNeighbors(grid, row, col, neighborsGrid);\n    }\n  }\n  return list;\n};\n\nexport const clone = (board) => {\n  const clone = [];\n  for (var i = 0; i < board.length; i++)\n    clone[i] = board[i].slice();\n  return clone;\n}\n","import { generateAdjList } from \"../index\";\n\n// Dijkstra's\n// 1. Create Shortest Path Tree (SPT)\n// 2. Assign distance value to all vertices in the input graph: Inifinity if not the source else zero.\n// 3. While SPT does not include all vertices\n//  a) Pick vertex not in SPT that has minimum distance value\n//  b) Include the vertex to SPT\n//  c) Update distance value of all adjacent vertices of u\n\nexport const dijkstra = async (grid, startRow, startCol) => {\n  const queue = [];\n  queue.push({\n    row: startRow,\n    col: startCol,\n    distance: 0,\n    predecesor: {\n      row: startRow,\n      col: startCol,\n    },\n  });\n  let count = 1;\n  const neighbors = generateAdjList(grid);\n  const animations = [];\n  const predecessors = [...grid];\n\n  while (queue.length !== 0) {\n    let item = queue.shift();\n    const adjacent = neighbors[item.row][item.col];\n    for (let i = 0; i < adjacent.length; i++) {\n      if (adjacent[i].distance === null) {\n        animations.push({ row: adjacent[i].row, col: adjacent[i].col });\n        // Since this is an unweightes graph, no point in comparing the distances\n        adjacent[i].distance = count;\n        adjacent[i].predecesor = { row: item.row, col: item.col };\n        predecessors[adjacent[i].row][adjacent[i].col] = ({ row: item.row, col: item.col });\n        queue.push(adjacent[i]);\n      }\n    }\n    count++;\n  }\n  return { animations, predecessors };\n};\n","import React, { useState, Fragment } from \"react\";\nimport useGrid from \"../hooks/useGrid\";\nimport Cell from \"./Cell\";\nimport Button from \"@material-ui/core/Button\";\nimport { bfs, dfs, clone, dijkstra, randomMaze } from \"../utility/index\";\nimport \"./Board.css\";\n\nconst ROWS_INIT = 20;\nconst COLS_INIT = 50;\nconst START_ROW = Math.floor(ROWS_INIT / 2);\nconst START_COL = Math.floor(COLS_INIT / 3);\n\nconst drawShortestPath = (row, col, predecessors, colStart, rowStart) => {\n  let nextObj = predecessors[row][col];\n  let currentCol = nextObj.col;\n  let currentRow = nextObj.row;\n  for (let row = 0; row < predecessors.length; row++) {\n    for (let col = 0; col < predecessors[row].length; col++) {\n      const classes = document.getElementById(`${row} ${col}`).classList;\n      if (classes.contains(\"ShortestPath\")) {\n        classes.remove(\"ShortestPath\");\n        // classes.add(\"FinalSearched\");\n      }\n    }\n  }\n  while (currentCol !== colStart || currentRow !== rowStart) {\n    const classes = document.getElementById(`${currentRow} ${currentCol}`)\n      .classList;\n    classes.remove(\"Searched\");\n    classes.add(\"ShortestPath\");\n\n    const nextObj = predecessors[currentRow][currentCol];\n    currentCol = nextObj.col;\n    currentRow = nextObj.row;\n  }\n};\n\nconst Board = () => {\n  const { grid, setCoord, resetGrid, initialCoords, targetCoords } = useGrid(\n    ROWS_INIT,\n    COLS_INIT,\n    START_ROW,\n    START_COL\n  );\n\n  const [isMouseDown, setIsMouseDown] = useState(false);\n  const [isMovingKeyItem, setIsMovingKeyItem] = useState([false, null]);\n  const [animationComplete, setAnimationComplete] = useState(false);\n  const [predecessors, setPredecessors] = useState(null);\n\n  let Grid = grid.map((row, rowNum) => {\n    return (\n      <tr>\n        {row.map((val, colNum) => {\n          return (\n            <Cell\n              key={[rowNum, colNum]}\n              val={val}\n              row={rowNum}\n              col={colNum}\n              isMouseDown={isMouseDown}\n              isMovingKeyItem={isMovingKeyItem}\n              setIsMovingKeyItem={setIsMovingKeyItem}\n              setCoord={setCoord}\n              animationComplete={animationComplete}\n              predecessors={predecessors}\n              drawShortestPath={() =>\n                drawShortestPath(\n                  rowNum,\n                  colNum,\n                  predecessors,\n                  initialCoords.startCol,\n                  initialCoords.startRow\n                )\n              }\n            />\n          );\n        })}\n      </tr>\n    );\n  });\n\n  const doSearch = async (type) => {\n    const rowStart = initialCoords.startRow;\n    const colStart = initialCoords.startCol;\n\n    const { animations, predecessors } = await type(\n      clone(grid),\n      rowStart,\n      colStart\n    );\n\n    setPredecessors(predecessors);\n\n    let count = 0;\n\n    const intervalId = setInterval(() => {\n      let row = animations[count].row;\n      let col = animations[count].col;\n      const cell = document.getElementById(`${row} ${col}`);\n\n      if (targetCoords.targetRow === row && targetCoords.targetCol === col) {\n        drawShortestPath(row, col, predecessors, colStart, rowStart);\n      } else {\n        !cell.classList.contains(\"Filled\") &&\n          !cell.classList.contains(\"Target\") &&\n          cell.classList.add(\"Searched\");\n      }\n\n      count++;\n\n      if (count >= animations.length) {\n        setAnimationComplete(true);\n        clearInterval(intervalId);\n      }\n    }, 3);\n  };\n\n  const clear = () => {\n    setAnimationComplete(false);\n    resetGrid(ROWS_INIT, COLS_INIT, START_ROW, START_COL);\n  };\n\n  console.log(grid);\n\n  return (\n    <Fragment>\n      <div style={{ margin: \"auto\" }}>\n        <Button onClick={() => doSearch(dfs)}>Do DFS</Button>\n        <Button onClick={() => doSearch(bfs)}>Do BFS</Button>\n        <Button onClick={() => doSearch(dijkstra)}>Dijkstra</Button>\n        <Button onClick={() => randomMaze(grid)}>Random Maze</Button>\n        <Button onClick={clear}>Clear</Button>\n      </div>\n      <table\n        onMouseDown={() => {\n          setIsMouseDown(true);\n        }}\n        onMouseUp={() => {\n          setIsMouseDown(false);\n        }}\n        draggable={false}\n        className=\"Board\"\n      >\n        <tbody>{Grid}</tbody>\n      </table>\n    </Fragment>\n  );\n};\n\nexport default Board;\n","export const randomMaze = (board) => {\n  for (let row = 0; row < board.length; row++) {\n    for (let col = 0; col < board[row].length; col++) {\n      if (board[row][col] === \" \") {\n        if (Math.random() <= 0.3) {\n          const classes = document.getElementById(`${row} ${col}`).classList;\n          classes.add(\"Wall\");\n        }\n      }\n    }\n  }\n};\n","import React from 'react';\nimport './App.css';\nimport Board from \"./components/Board\"\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <h1 style={{margin: \"auto\"}}>Graphing Algorithm Visualization</h1>\n      <Board/>\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}