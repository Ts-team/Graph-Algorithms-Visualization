{"version":3,"sources":["hooks/useGrid.js","components/Cell.js","utility/GraphAlgorithms/AStar.js","utility/MazeGenerators/RecursiveDivision.js","utility/generateGraph.js","utility/DS/Queue.js","utility/DS/Graph.js","utility/DS/MinHeap.js","utility/Node.js","hooks/useNodeGrid.js","components/Board.js","utility/MazeGenerators/Random.js","App.js","index.js"],"names":["useGrid","numRows","numCols","startRow","startCol","initialRow","initialCol","targetRow","Math","floor","targetCol","useState","arr","row","col","createGrid","grid","setGrid","initialCoords","setInitialCoords","targetCoords","setTargetCoords","setCoord","val","newGrid","resetGrid","cell","document","getElementById","classList","contains","React","memo","isMouseDown","isMovingKeyItem","setIsMovingKeyItem","animationComplete","node","classes","push","className","join","id","onMouseDown","isTarget","isStart","onMouseEnter","setWall","setAsTarget","setAsStart","markShortestPath","onMouseLeave","remove","onMouseUp","draggable","prevState","nextState","getNeighbors","neighborsGrid","cellNotInGraph","neighbors","length","initializeClosedList","g","manhattanDistance","f","h","predecesor","rowOne","colOne","rowTwo","colTwo","abs","getMinF","openList","min","Infinity","result","i","recursiveDivision","a","drawContourWalls","width","height","prohibitedCells","divide","chooseOrientation","orientation","prohibited","horizontal","whereCol","ceil","random","whereRow","passCol","passRow","drawWall","newwidth","newheight","newwidth2","newheight2","isProhibitedCoord","add","isBorder","updateProhibitedCells","j","isWall","generateNodeGrid","nodesGrid","graph","Graph","getElementsByClassName","addVertex","generateGraph","startNode","currentNode","addEdge","dist","Queue","this","items","element","isEmpty","shift","str","noOfVertices","AdjList","Map","v","set","w","get","get_keys","keys","get_values","conc","console","log","startingNode","animations","visited","q","enqueue","getQueueElement","dequeue","get_List","n","neigh","predecessor","DFSUtil","vert","get_neighbours","get_elem","heap","MinHeap","item","pop","currentdist","adj","adjacentNode","d","selector","parentIndex","parentVal","pushedVal","swap","max","t","ret","temp","rightChildIndex","leftChildIndex","lowest","includes","indexOf","Node","useNodeGrid","newNode","nodeGrid","useRef","current","reset","START_ROW","ROWS_INIT","START_COL","Board","setIsMouseDown","setAnimationComplete","Grid","map","rowNum","colNum","key","clear","animate","count","intervalId","setInterval","markSearched","clearInterval","style","margin","Button","onClick","dfs","bfs","dijkstra","board","randomMaze","AStar","gridTemplateRows","gridTemplateColumns","App","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.77d3eb84.chunk.js","sourcesContent":["import { useState } from \"react\";\n\nconst createGrid = (numRows, numCols, startRow, startCol) => {\n  let arr = [];\n  for (let row = 0; row < numRows; row++) {\n    arr[row] = [];\n    for (let col = 0; col < numCols; col++) {\n      arr[row][col] = \" \";\n    }\n  }\n  arr[startRow][startCol] = \"s\";\n  arr[Math.floor(numRows / 2)][Math.floor((numCols * 2) / 3)] = \"t\";\n  return arr;\n};\n\nconst useGrid = (numRows, numCols, startRow, startCol) => {\n  let initialRow = startRow;\n  let initialCol = startCol;\n  let targetRow = Math.floor(numRows / 2);\n  let targetCol = Math.floor((numCols * 2) / 3);\n\n  const [grid, setGrid] = useState(\n    createGrid(numRows, numCols, initialRow, initialCol)\n  );\n\n  const [initialCoords, setInitialCoords] = useState({\n    startRow,\n    startCol,\n  });\n  const [targetCoords, setTargetCoords] = useState({\n    targetRow,\n    targetCol,\n  });\n\n  const setCoord = (row, col, val) => {\n    let newGrid = [...grid];\n    if (val === \"s\") {\n      setInitialCoords({ startRow: row, startCol: col });\n    }\n    if (val === \"t\") {\n      setTargetCoords({ targetRow: row, targetCol: col });\n    }\n    newGrid[row][col] = val;\n    setGrid(newGrid);\n  };\n\n  const resetGrid = (numRows, numCols) => {\n    for (let row = 0; row < numRows; row++) {\n      for (let col = 0; col < numCols; col++) {\n        const cell = document.getElementById(`${row} ${col}`);\n        if (\n          !cell.classList.contains(\"Target\") &&\n          !cell.classList.contains(\"Filled\")\n        ) {\n          cell.classList = [\"Cell\"];\n        }\n      }\n    }\n  };\n\n  return {\n    grid,\n    setGrid,\n    setCoord,\n    resetGrid,\n    initialCoords,\n    targetCoords,\n  };\n};\n\nexport default useGrid;\n","import React from \"react\";\nimport \"./Cell.css\";\n\nconst Cell = ({\n  val,\n  row,\n  col,\n  isMouseDown,\n  isMovingKeyItem,\n  setIsMovingKeyItem,\n  animationComplete,\n  node,\n}) => {\n  let classes = [\"Cell\"];\n\n  if (node.row === 10 && node.col === 10) {\n    classes.push(\"Filled\");\n  }\n  if (node.row === 10 && node.col === 30) {\n    classes.push(\"Target\");\n  }\n\n  const onMoveHandler = () => {\n    if (isMouseDown && !isMovingKeyItem[0]) {\n      node.setWall();\n    }\n    if (isMovingKeyItem[0] && !animationComplete) {\n      if (isMovingKeyItem[1] === \"t\") {\n        node.setAsTarget();\n      } else {\n        node.setAsStart();\n      }\n    }\n    if (isMovingKeyItem[0] && animationComplete) {\n      node.markShortestPath();\n    }\n  };\n\n  const onLeaveHandler = () => {\n    const cell = document.getElementById(`${row} ${col}`);\n    if (isMouseDown && isMovingKeyItem[0]) {\n      if (isMovingKeyItem[1] === \"t\") {\n        cell.classList.remove(\"Target\");\n      } else {\n        cell.classList.remove(\"Filled\");\n      }\n    }\n  };\n\n  const onClickHandler = () => {\n    if (node.isTarget()) {\n      setIsMovingKeyItem([true, \"t\"]);\n    }\n    if(node.isStart()){\n      setIsMovingKeyItem([true, \"s\"]);\n    }\n  };\n\n  const onMouseUpHandler = () => {\n    if (isMovingKeyItem[1]) {\n      // Set coord and set IsNotmoving key item\n      // setCoord(row, col, isMovingKeyItem[1]);\n      setIsMovingKeyItem(false);\n    }\n  };\n\n  return (\n    <div\n      className={classes.join(\" \")}\n      id={`${row} ${col}`}\n      onMouseDown={onClickHandler}\n      onMouseEnter={onMoveHandler}\n      onMouseLeave={onLeaveHandler}\n      onMouseUp={onMouseUpHandler}\n      draggable={false}\n    ></div>\n  );\n};\n\nconst compare = (prevState, nextState) => {\n  return (\n    prevState.val === nextState.val &&\n    prevState.isMouseDown === nextState.isMouseDown\n  );\n};\n\nexport default React.memo(Cell, compare);\n","export const AStar = (startRow, startCol, targetRow, targetCol, grid) => {\n  const openList = initializeClosedList(grid, targetRow, targetCol); // generates a list of all nodes with their respective f values\n  const animations = [];\n  //   const closedList = [];\n  let currentNode = getNeighbors(grid, startRow, startCol, openList);\n  currentNode = getMinF(currentNode);\n\n  while (openList.length !== 0) {\n    // Find the node with the least f on the open list call it \"q\"\n\n    // Pop q off the open list\n    // generate q neighbors and set their parents to q\n    const neighbors = getNeighbors(\n      grid,\n      currentNode.row,\n      currentNode.col,\n      openList\n    );\n    console.log(neighbors);\n    // for each neighbor\n\n    for (let i = 0; i < neighbors.length; i++) {\n      // A) if it is the goal, stop search\n      if (neighbors[i].row === targetRow && neighbors[i].col === targetCol)\n        return animations;\n      // succesor.g = q.g + distance between neighbor and q;\n      neighbors[i].g = neighbors[i].g + 1;\n\n      // successor.h = distance from goal to successor (heuristics)\n      // successor.f = successor.g + successor.h\n      \n      // B) if a node with the same position as neighbotr is in the open list with lower f skip it.\n      // C) if a node with same position as neighbor is in the closed list with lower f, skip\n      // else add node to open list\n      // EndFor\n    }\n\n    currentNode = getMinF(neighbors);\n    console.log(\"new currentnode\", currentNode);\n\n    // Push Q on the closed list\n    // EndWhile\n  }\n};\n\nconst getNeighbors = (grid, row, col, neighborsGrid) => {\n  const cellNotInGraph = (row, col) => {\n    const cellClasses = document.getElementById(`${row} ${col}`).classList;\n    return cellClasses.contains(\"Wall\");\n  };\n  if (cellNotInGraph(row, col)) return [];\n  let neighbors = [];\n\n  if (row > 0 && !cellNotInGraph(row - 1, col)) {\n    // N\n    neighbors.push(neighborsGrid[row - 1][col]);\n  }\n  if (col > 0 && !cellNotInGraph(row, col - 1)) {\n    // W\n    neighbors.push(neighborsGrid[row][col - 1]);\n  }\n  if (row < grid.length - 1 && !cellNotInGraph(row + 1, col)) {\n    // S\n    neighbors.push(neighborsGrid[row + 1][col]);\n  }\n  if (col < grid[row].length - 1 && !cellNotInGraph(row, col + 1)) {\n    // E\n    neighbors.push(neighborsGrid[row][col + 1]);\n  }\n  if (row > 0 && col > 0 && !cellNotInGraph(row - 1, col - 1)) {\n    // NW\n    neighbors.push(neighborsGrid[row - 1][col - 1]);\n  }\n  if (\n    row > 0 &&\n    col < grid[row].length - 1 &&\n    !cellNotInGraph(row - 1, col + 1)\n  ) {\n    // NE\n    neighbors.push(neighborsGrid[row - 1][col + 1]);\n  }\n  if (row < grid.length - 1 && col > 0 && !cellNotInGraph(row + 1, col - 1)) {\n    // SW\n    neighbors.push(neighborsGrid[row + 1][col - 1]);\n  }\n  if (\n    row < grid.length - 1 &&\n    col < grid[row].length - 1 &&\n    !cellNotInGraph(row + 1, col + 1)\n  ) {\n    // SE\n    neighbors.push(neighborsGrid[row + 1][col + 1]);\n  }\n\n  return neighbors;\n};\n\nconst initializeClosedList = (grid, targetRow, targetCol) => {\n  let arr = {};\n  for (let row = 0; row < grid.length; row++) {\n    for (let col = 0; col < grid[row].length; col++) {\n      const g = manhattanDistance(row, col, targetRow, targetCol);\n      const h = 0;\n      const f = g + h;\n      arr[`${row} ${col}`] = {\n        row,\n        col,\n        g,\n        h,\n        f,\n        predecesor: null,\n      };\n    }\n  }\n  return arr;\n};\n\nconst manhattanDistance = (rowOne, colOne, rowTwo, colTwo) => {\n  let xChange = Math.abs(colOne - colTwo);\n  let yChange = Math.abs(rowOne - rowTwo);\n  return xChange + yChange;\n};\n\nconst getMinF = (openList) => {\n  // Takes O(n^2) in future use another DS\n  let min = Infinity;\n  let result = {};\n  for (let i = 0; i < openList.length; i++) {\n    if (openList[i].f < min) {\n      min = openList[i].f;\n      result = openList[i];\n    }\n  }\n  return result;\n};\n","const HORIZONTAL = \"horizontal\";\nconst VERTICAL = \"vertical\";\n\nexport const recursiveDivision = async (grid) => {\n  drawContourWalls(grid);\n  const width = grid[0].length - 2; // Subtract 2 since we drew a contour\n  const height = grid.length - 2;\n  let prohibitedCells = [];\n  divide(\n    1,\n    1,\n    width,\n    height,\n    chooseOrientation(width, height),\n    prohibitedCells\n  );\n  // console.log(prohibitedCells);\n  // for (let i = 0; i < prohibitedCells.length; i++) {\n  //   const cell = document.getElementById(\n  //     `${prohibitedCells[i][0]} ${prohibitedCells[i][1]}`\n  //   );\n  //   if (cell) {\n  //     cell.classList.add(\"Filled\");\n  //   }\n  // }\n  // for (let i = 0; i < grid.length; i++) {\n  //   for (let j = 0; j < grid[i].length; j++) {\n  //     if (isProhibitedCoord(i, j, prohibitedCells)) {\n  //       console.log(i, j);\n  //     }\n  //   }\n  // }\n};\n\nconst divide = (col, row, width, height, orientation, prohibited) => {\n  //   console.log(\"divide with starting coords\", row, col);\n  //   console.log(\"divide with width and height\", width, height);\n  if (width <= 2 || height <= 2 ) return;\n\n  const horizontal = orientation === HORIZONTAL;\n\n  // Where will the wall be drawn from?\n  let whereCol =\n    col + (horizontal ? 0 : Math.ceil(Math.random() * (width - 2))); // Rand number between the col and width\n\n  let whereRow =\n    row + (horizontal ? Math.ceil(Math.random() * (height - 2)) : 0); // Rand number between the row and height\n\n  // Where will the passage through the wall exist?\n  const passCol =\n    whereCol + (horizontal ? Math.ceil(Math.random() * (width - 1)) : 0); // Rand number between the col and width\n  const passRow =\n    whereRow + (horizontal ? 0 : Math.ceil(Math.random() * (height - 1))); // Rand number between the row and height\n\n  // How long will the wall be?\n  const length = horizontal ? width : height;\n\n  // Draw the walls\n  drawWall(\n    whereRow,\n    whereCol,\n    passRow,\n    passCol,\n    horizontal,\n    length,\n    prohibited\n  );\n\n  let newCol = row;\n  let newRow = col;\n\n  let newwidth = horizontal ? width : whereCol - col;\n  let newheight = horizontal ? whereRow - row : height;\n  divide(\n    newCol,\n    newRow,\n    newwidth,\n    newheight,\n    chooseOrientation(newwidth, newheight),\n    prohibited\n  );\n\n  let newCol2 = horizontal ? col : whereCol + 1;\n  let newRow2 = horizontal ? whereRow + 1 : row;\n\n  let newwidth2 = horizontal ? width : col + width - whereCol - 1;\n  let newheight2 = horizontal ? row + height - whereRow - 1 : height;\n  // console.log(\n  //   \"divide to be called with col row width height\",\n  //   newCol,\n  //   newRow,\n  //   newwidth,\n  //   newheight\n  // );\n  divide(\n    newCol2,\n    newRow2,\n    newwidth2,\n    newheight2,\n    chooseOrientation(newwidth2, newheight2),\n    prohibited\n  );\n};\n\nconst drawWall = (\n  startRow,\n  startCol,\n  passRow,\n  passCol,\n  horizontal,\n  length,\n  prohibited\n) => {\n  // console.log(\"drawing with coords and length\", startRow, startCol, length);\n  for (let i = 0; i < length; i++) {\n    const row = startRow + (horizontal ? 0 : i);\n    const col = startCol + (horizontal ? i : 0);\n\n    const cell = document.getElementById(`${row} ${col}`);\n\n    if (\n      cell &&\n      !cell.classList.contains(\"Target\") &&\n      !cell.classList.contains(\"Filled\") &&\n      !isProhibitedCoord(row, col, prohibited)\n    ) {\n      cell.classList.add(\"Wall\");\n    }\n  }\n\n  const cell = document.getElementById(`${passRow} ${passCol}`);\n  if (cell && !isBorder(passRow, passCol)) {\n    // console.log(\n    //   isProhibitedCoord(passRow, passCol, prohibited),\n    //   passRow,\n    //   passCol\n    // );\n    cell.classList.remove(\"Wall\");\n  }\n  updateProhibitedCells(passRow, passCol, horizontal, prohibited);\n};\n\nconst chooseOrientation = (width, height) => {\n  if (width < height) {\n    return HORIZONTAL;\n  }\n  return VERTICAL;\n};\n\nconst drawContourWalls = (grid) => {\n  for (let i = 0; i < grid.length; i++) {\n    let classes = document.getElementById(`${i} ${0}`).classList;\n    classes.add(\"Wall\");\n    classes = document.getElementById(`${i} ${grid[i].length - 1}`).classList;\n    classes.add(\"Wall\");\n  }\n\n  for (let j = 0; j < grid[0].length; j++) {\n    let classes = document.getElementById(`${0} ${j}`).classList;\n    classes.add(\"Wall\");\n    classes = document.getElementById(`${grid.length - 1} ${j}`).classList;\n    classes.add(\"Wall\");\n  }\n};\n\nconst updateProhibitedCells = (row, col, horizontal, prohibited) => {\n  // console.log(\"updateProhibited passCoords\", row, col);\n  if (!horizontal) {\n    prohibited.push([row, col + 1]);\n    prohibited.push([row, col - 1]);\n  } else {\n    prohibited.push([row + 1, col]);\n    prohibited.push([row - 1, col]);\n  }\n};\n\nconst isProhibitedCoord = (row, col, prohibited) => {\n  for (let i = 0; i < prohibited.length; i++) {\n    if (prohibited[i][0] === row && prohibited[i][1] === col) return true;\n  }\n  return false;\n};\n\nconst isBorder = (row, col) => {\n  return row === 0 || row === 19 || col === 0 || col === 49;\n}\n","import { Graph } from \"./index\";\n\nconst getNeighbors = (grid, row, col) => {\n  const cellNotInGraph = (row, col) => {\n    return grid[row][col].isWall();\n  };\n\n  if (cellNotInGraph(row, col)) return [];\n  let neighbors = [];\n\n  if (row > 0 && !cellNotInGraph(row - 1, col)) {\n    // N\n    neighbors.push(grid[row - 1][col]);\n  }\n  if (col > 0 && !cellNotInGraph(row, col - 1)) {\n    // W\n    neighbors.push(grid[row][col - 1]);\n  }\n  if (row < grid.length - 1 && !cellNotInGraph(row + 1, col)) {\n    // S\n    neighbors.push(grid[row + 1][col]);\n  }\n  if (col < grid[row].length - 1 && !cellNotInGraph(row, col + 1)) {\n    // E\n    neighbors.push(grid[row][col + 1]);\n  }\n\n  return neighbors;\n};\n\nexport const calculateNumVertices = () => {\n  const numCells = document.getElementsByClassName(\"Cell\").length;\n  const numWalls = document.getElementsByClassName(\"Wall\").length;\n  return numCells - numWalls;\n};\n\nexport const generateNodeGrid = (grid) => {\n  const nodesGrid = [];\n  const graph = new Graph(calculateNumVertices());\n\n  for (let row in grid) {\n    nodesGrid[row] = [];\n    for (let col in grid[row]) {\n      graph.addVertex(grid[row][col]);\n    }\n  }\n  return graph;\n};\n\nexport const generateGraph = (nodesGrid) => {\n  let startNode = null;\n  const graph = generateNodeGrid(nodesGrid);\n\n  for (let row = 0; row < nodesGrid.length; row++) {\n    for (let col = 0; col < nodesGrid[row].length; col++) {\n      const currentNode = nodesGrid[row][col];\n\n      if (!currentNode.isWall()) {\n        if (currentNode.isStart()) startNode = currentNode;\n\n        const neighbors = getNeighbors(nodesGrid, row, col);\n\n        for (let i in neighbors) {\n          graph.addEdge(currentNode, neighbors[i]);\n        }\n      }\n    }\n  }\n  startNode.dist = 0;\n  return { graph, startNode };\n};\n","// Queue class\nexport class Queue {\n  // Array is used to implement a Queue\n  constructor() {\n    this.items = [];\n  }\n\n  // enqueue(item)\n  enqueue(element) {\n    // adding element to the queue\n    this.items.push(element);\n  }\n\n  // dequeue()\n  dequeue() {\n    // removing element from the queue\n    // returns underflow when called\n    // on empty queue\n    if (this.isEmpty()) return \"Underflow\";\n    return this.items.shift();\n  }\n\n  // front()\n  front() {\n    // returns the Front element of\n    // the queue without removing it.\n    if (this.isEmpty()) return \"No elements in Queue\";\n    return this.items[0];\n  }\n\n  // isEmpty()\n  isEmpty() {\n    // return true if the queue is empty.\n    return this.items.length === 0;\n  }\n\n  // printQueue()\n  printQueue() {\n    var str = \"\";\n    for (var i = 0; i < this.items.length; i++) str += this.items[i] + \" \";\n    return str;\n  }\n}\n\n// // creating object for queue class \n// var queue = new Queue(); \n              \n  \n// // Testing dequeue and pop on an empty queue \n// // returns Underflow \n// console.log(queue.dequeue()); \n  \n// // returns true \n// console.log(queue.isEmpty()); \n  \n// // Adding elements to the queue \n// // queue contains [10, 20, 30, 40, 50] \n// queue.enqueue(10); \n// queue.enqueue(20); \n// queue.enqueue(30); \n// queue.enqueue(40); \n// queue.enqueue(50); \n// queue.enqueue(60); \n  \n// // returns 10 \n// console.log(queue.front()); \n  \n// // removes 10 from the queue \n// // queue contains [20, 30, 40, 50, 60] \n// console.log(queue.dequeue()); \n  \n// // returns 20 \n// console.log(queue.front()); \n  \n// // removes 20 \n// // queue contains [30, 40, 50, 60] \n// console.log(queue.dequeue()); \n  \n// // printing the elements of the queue \n// // prints [30, 40, 50, 60] \n// console.log(queue.printQueue()); \n","import { Queue } from \"./Queue\";\nimport { MinHeap } from \"../index\";\n\n// create a graph class\nexport class Graph {\n  // defining vertex array and\n  // adjacent list\n  constructor(noOfVertices) {\n    this.noOfVertices = noOfVertices;\n    this.AdjList = new Map();\n  }\n\n  // functions to be implemented\n\n  // addVertex(v)\n  // add vertex to the graph\n  addVertex(v) {\n    // initialize the adjacent list with a\n    // null array\n    this.AdjList.set(v, []);\n  }\n\n  // addEdge(v, w)\n  // add edge to the graph\n  addEdge(v, w) {\n    // get the list for vertex v and put the\n    // vertex w denoting edge between v and w\n    this.AdjList.get(v).push(w);\n\n    // Since graph is undirected,\n    // add an edge from w to v also\n    // this.AdjList.get(w).push(v);\n  }\n  // printGraph()\n  // Prints the vertex and adjacency list\n  printGraph() {\n    // get all the vertices\n    var get_keys = this.AdjList.keys();\n\n    // iterate over the vertices\n    for (var i of get_keys) {\n      // great the corresponding adjacency list\n      // for the vertex\n      var get_values = this.AdjList.get(i);\n      var conc = \"\";\n\n      // iterate over the adjacency list\n      // concatenate the values into a string\n      for (var j of get_values) conc += j + \" \";\n\n      // print the vertex and its adjacency list\n      console.log(i + \" -> \" + conc);\n    }\n  }\n\n  // bfs(v)\n  // function to performs BFS\n  bfs(startingNode) {\n    // create a visited array\n    const animations = [];\n\n    var visited = [];\n    for (var i = 0; i < this.noOfVertices; i++) visited[i] = false;\n\n    // Create an object for queue\n    var q = new Queue();\n\n    // add the starting node to the queue\n    visited[startingNode] = true;\n    q.enqueue(startingNode);\n\n    // loop until queue is element\n    while (!q.isEmpty()) {\n      // get the element from the queue\n      var getQueueElement = q.dequeue();\n\n      // passing the current vertex to callback funtion\n      // console.log(getQueueElement);\n\n      // get the adjacent list for current vertex\n      var get_List = this.AdjList.get(getQueueElement);\n\n      // loop through the list and add the element to the\n      // queue if it is not processed yet\n      for (var n in get_List) {\n        var neigh = get_List[n];\n\n        if (!visited[neigh]) {\n          neigh.predecessor = getQueueElement;\n          animations.push(neigh);\n          visited[neigh] = true;\n          q.enqueue(neigh);\n        }\n      }\n    }\n\n    return animations;\n  }\n\n  // dfs(v)\n  // Main DFS method\n  dfs(startingNode) {\n    const animations = [];\n\n    var visited = [];\n    for (var i = 0; i < this.noOfVertices; i++) visited[i] = false;\n\n    this.DFSUtil(startingNode, visited, animations);\n\n    return animations;\n  }\n\n  // Recursive function which process and explore\n  // all the adjacent vertex of the vertex with which it is called\n  DFSUtil(vert, visited, animations) {\n    visited[vert] = true;\n    console.log(vert);\n\n    var get_neighbours = this.AdjList.get(vert);\n\n    for (var i in get_neighbours) {\n      var get_elem = get_neighbours[i];\n      if (!visited[get_elem]) {\n        get_elem.predecessor = vert;\n        animations.push(get_elem);\n        this.DFSUtil(get_elem, visited, animations);\n      }\n    }\n  }\n\n  //dijkstra solve graph starting at s\n  dijkstra(startNode) {\n    const animations = [];\n\n    const heap = new MinHeap((item) => item.dist);\n\n    // startNode.dist = 0;\n    // console.log(startNode);\n    heap.push(startNode);\n\n    console.log(heap.items.length);\n\n    while (!heap.isEmpty()) {\n      //for each existing solution\n      const currentNode = heap.pop();\n      console.log(currentNode);\n\n      var currentdist = currentNode.dist;\n      var adj = this.AdjList.get(currentNode); // get neighbors\n\n      //for each of its adjacent nodes...\n      console.log(\"Adjacent Nodes:\", adj);\n      for (var a in adj) {\n        const adjacentNode = adj[a];\n\n        //choose nearest node with lowest *total* cost\n        var d = 1 + currentdist;\n        // console.log(heap.contains(adjacentNode))\n        if (d < adjacentNode.dist && !heap.contains(adjacentNode)) {\n          animations.push(adjacentNode);\n          heap.push(adjacentNode);\n          //reference parent\n          adjacentNode.predecessor = currentNode;\n          adjacentNode.dist = d;\n        }\n      }\n    }\n    console.log(animations);\n    return animations;\n  }\n}\n","export class MinHeap {\n  constructor(selector) {\n    this.items = [];\n    this.selector = selector;\n  }\n\n  seek() {\n    return this.items[0];\n  }\n\n  push(item) {\n    let i = this.items.length;\n    this.items.push(item);\n\n    let parentIndex = Math.floor((i + 1) / 2 - 1);\n\n    if (parentIndex < 0) parentIndex = 0;\n\n    // console.log(\"ParentIndex\", parentIndex);\n\n    let parentVal = this.selector(this.items[parentIndex]);\n    const pushedVal = this.selector(this.items[i]);\n\n    // console.log(\"ParentVal, parentIndex:\", parentVal, parentIndex);\n    // console.log(\"PushedVal\", pushedVal);\n\n    while (i > 0 && parentVal > pushedVal) {\n      parentIndex = Math.floor((i + 1) / 2 - 1);\n      // console.log(\n      //   \"INSIDE LOOP ParentVal, parentIndex:\",\n      //   parentVal,\n      //   parentIndex\n      // );\n\n      this.swap(i, parentIndex);\n\n      i = parentIndex;\n      // console.log(\n      //   \"New INSIDE LOOP parentIndex:\",\n      //   Math.max(Math.floor((i + 1) / 2 - 1), 0)\n      // );\n\n      parentVal = this.selector(\n        this.items[Math.max(Math.floor((i + 1) / 2 - 1), 0)]\n      );\n    }\n\n    // this.print();\n  }\n\n  swap(i, j) {\n    let t = this.items[i];\n    this.items[i] = this.items[j];\n    this.items[j] = t;\n  }\n\n  pop() {\n    // console.log(\"Items before pop:\", this.items);\n    if (this.items.length <= 1) return this.items.pop(); //If it is the last element pop it\n    const ret = this.items[0]; // What we will return\n    let temp = this.items.pop();\n    this.items[0] = temp; // Place last element in array at front\n\n    // console.log(\"Items after pop:\", this.items); // Good till here\n    let i = 0; // We adjust heap from top to down\n\n    while (true) {\n      let rightChildIndex = (i + 1) * 2;\n      let leftChildIndex = (i + 1) * 2 - 1;\n\n      // console.log(\"rightIndex\", rightChildIndex);\n      // console.log(\"rightValue\", this.items[rightChildIndex]);\n      // console.log(\"leftIndex\", leftChildIndex);\n      // console.log(\"leftValue\", this.items[leftChildIndex]);\n      let lowest = rightChildIndex;\n\n      if (\n        leftChildIndex >= this.items.length &&\n        rightChildIndex >= this.items.length\n      )\n        break;\n      if (leftChildIndex >= this.items.length) lowest = rightChildIndex;\n      if (rightChildIndex >= this.items.length) lowest = leftChildIndex;\n\n      if (\n        !(leftChildIndex >= this.items.length) &&\n        !(rightChildIndex >= this.items.length)\n      ) {\n        lowest =\n          this.selector(this.items[rightChildIndex]) <\n          this.selector(this.items[leftChildIndex])\n            ? rightChildIndex\n            : leftChildIndex;\n      } // Find the smallest child\n\n      // If the parent is greater than the smallest child: swap\n      if (this.selector(this.items[i]) > this.selector(this.items[lowest])) {\n        this.swap(i, lowest);\n        i = lowest;\n      } else break; // We have finished setting up the heap\n    }\n\n    // Return topmost element\n    return ret;\n  }\n\n  contains(item) {\n    return this.items.includes(item);\n  }\n\n  isEmpty() {\n    return this.items.length === 0;\n  }\n\n  delete(item) {\n    let i = this.items.indexOf(item);\n    // heapify\n    this.items[i] = this.items.pop();\n    while (true) {\n      let lowest =\n        this.selector(this.items[(i + 1) * 2]) <\n        this.selector(this.items[(i + 1) * 2 - 1])\n          ? (i + 1) * 2\n          : (i + 1) * 2 - 1;\n      if (this.selector(this.items[i]) > this.selector(this.items[lowest])) {\n        let t = this.items[i];\n        this.items[i] = this.items[lowest];\n        this.items[lowest] = t;\n        i = lowest;\n      } else break;\n    }\n  }\n\n  print() {\n    for (let i = 0; i < this.items.length; i++) {\n      console.log(this.items[i]);\n    }\n  }\n\n  heapify(arr) {\n    for (let i = 0; i < arr.length; i++) {\n      this.push(arr[i]);\n    }\n  }\n}\n\n// const heap = new MinHeap((x) => x.dist);\n// heap.heapify([6, 3, 6, 9, 43, 0, 8, 0, 8]);\n// console.log(heap);\n// console.log(heap.isEmpty());\n\n// heap.heapify([1, 2, 7, 4, 8, 0, 4, 2, 7, 3]);\n\n// heap.heapify([\n//   { dist: 1 },\n//   { dist: 2 },\n//   { dist: 7 },\n//   { dist: 4 },\n//   { dist: 8 },\n//   { dist: 0 },\n//   { dist: 4 },\n//   { dist: 2 },\n//   { dist: 7 },\n//   { dist: 3 },\n// ]);\n\n// heap.heapify([\n//   { dist: 1 },\n//   { dist: 2 },\n//   { dist: 7 },\n//   { dist: 4 },\n//   { dist: 8 },\n//   { dist: 0 },\n//   { dist: 4 },\n//   { dist: 2 },\n//   { dist: 7 },\n//   { dist: 3 },\n//   { dist: 23 },\n//   { dist: 200 },\n//   { dist: -1 },\n// ]);\n\n// heap.print();\n// // const a = heap.pop()\n// // heap.pop()\n// // heap.pop()\n\n// console.log(heap.items);\n\n// while (!heap.isEmpty()) {\n//   // console.log(\"Length\", heap.items.length);\n//   const a = heap.pop();\n//   console.log(\"Value:\", a);\n//   // console.log(\"Length\", heap.items.length);\n// }\n","export default class Node {\n  constructor(row, col) {\n    this.row = row;\n    this.col = col;\n    this.predecessor = null;\n    this.dist = Infinity;\n  }\n\n  toString() {\n    return \"(\" + this.row + \" \" + this.col + \")\";\n  }\n\n  setWall() {\n    if (this.isTarget() || this.isStart()) return;\n    const cell = document.getElementById(`${this.row} ${this.col}`);\n    cell.classList.add(\"Wall\");\n  }\n\n  setAsTarget() {\n    const cell = document.getElementById(`${this.row} ${this.col}`);\n    cell.classList.add(\"Target\");\n  }\n\n  setAsStart() {\n    const cell = document.getElementById(`${this.row} ${this.col}`);\n    cell.classList.add(\"Filled\");\n  }\n\n  markSearched() {\n    if (this.isTarget()) return;\n    const cell = document.getElementById(`${this.row} ${this.col}`);\n    cell.classList.add(\"Searched\");\n  }\n\n  reset() {\n    const cell = document.getElementById(`${this.row} ${this.col}`);\n    cell.classList.remove(\"ShortestPath\");\n    cell.classList.remove(\"Wall\");\n    cell.classList.remove(\"Searched\");\n    this.predecessor = null;\n    this.dist = Infinity;\n  }\n\n  isTarget() {\n    const cell = document.getElementById(`${this.row} ${this.col}`);\n    return cell.classList.contains(\"Target\");\n  }\n\n  isStart() {\n    const cell = document.getElementById(`${this.row} ${this.col}`);\n    return cell.classList.contains(\"Filled\");\n  }\n\n  isWall() {\n    const cell = document.getElementById(`${this.row} ${this.col}`);\n    return cell.classList.contains(\"Wall\");\n  }\n\n  isPartOfGraph() {\n    return !this.isWall();\n  }\n\n  markShortestPath() {\n    const cell = document.getElementById(`${this.row} ${this.col}`);\n    if (!this.isTarget() && !this.isStart()) {\n      cell.classList.remove(\"Searched\");\n      cell.classList.add(\"ShortestPath\");\n    }\n    if (this.predecessor != null) {\n      this.predecessor.markShortestPath();\n    }\n  }\n}\n","import { useRef } from \"react\";\nimport Node from \"../utility/Node\";\n\nconst generateNodeGrid = (numRows, numCols) => {\n  const nodesGrid = [];\n\n  for (let row = 0; row < numRows; row++) {\n    nodesGrid[row] = [];\n    for (let col = 0; col < numCols; col++) {\n      const newNode = new Node(row, col);\n      nodesGrid[row][col] = newNode;\n    }\n  }\n\n  return nodesGrid;\n};\n\nconst useNodeGrid = () => {\n  const nodesGrid = generateNodeGrid(20, 50);\n  const nodeGridRef = useRef(nodesGrid);\n  const nodeGrid = nodeGridRef.current;\n\n  const resetGrid = () => {\n      for(let row in nodeGrid){\n          for(let col in nodeGrid[row]){\n              nodeGrid[row][col].reset();\n          }\n      }\n  }\n  return { nodeGrid, resetGrid };\n};\n\nexport default useNodeGrid;\n","import React, { useState, Fragment } from \"react\";\nimport useGrid from \"../hooks/useGrid\";\nimport Cell from \"./Cell\";\nimport Button from \"@material-ui/core/Button\";\nimport {\n  randomMaze,\n  recursiveDivision,\n  AStar,\n  generateGraph,\n} from \"../utility/index\";\nimport \"./Board.css\";\nimport useNodeGrid from \"../hooks/useNodeGrid\";\n\nconst ROWS_INIT = 20;\nconst COLS_INIT = 50;\nconst START_ROW = Math.floor(ROWS_INIT / 2);\nconst START_COL = Math.floor(COLS_INIT / 3);\n\nconst Board = () => {\n  const { grid, initialCoords, targetCoords } = useGrid(\n    ROWS_INIT,\n    COLS_INIT,\n    START_ROW,\n    START_COL\n  );\n  const { nodeGrid, resetGrid } = useNodeGrid();\n  const [isMouseDown, setIsMouseDown] = useState(false);\n  const [isMovingKeyItem, setIsMovingKeyItem] = useState([false, null]);\n  const [animationComplete, setAnimationComplete] = useState(false);\n\n  let Grid = grid.map((row, rowNum) => {\n    return row.map((val, colNum) => {\n      return (\n        <Cell\n          key={[rowNum, colNum]}\n          val={val}\n          node={nodeGrid[rowNum][colNum]}\n          row={rowNum}\n          col={colNum}\n          isMouseDown={isMouseDown}\n          isMovingKeyItem={isMovingKeyItem}\n          setIsMovingKeyItem={setIsMovingKeyItem}\n          animationComplete={animationComplete}\n        />\n      );\n    });\n  });\n\n  const BFS = () => {\n    const { startNode, graph } = generateGraph(nodeGrid);\n    // graph.printGraph()\n    const animations = graph.bfs(startNode);\n    animate(animations);\n  };\n\n  const DFS = () => {\n    const { startNode, graph } = generateGraph(nodeGrid);\n    const animations = graph.dfs(startNode);\n    animate(animations);\n  };\n\n  const Dijkstra = () => {\n    const { startNode, graph } = generateGraph(nodeGrid);\n    const animations = graph.dijkstra(startNode);\n    animate(animations);\n  };\n\n  const clear = () => {\n    setAnimationComplete(false);\n    resetGrid();\n  };\n\n  const doRandomMaze = () => {\n    clear();\n    randomMaze(nodeGrid);\n  };\n\n  const doRecursiveDivision = () => {\n    clear();\n    recursiveDivision(nodeGrid);\n  };\n\n  const doAStar = () => {\n    const animations = AStar(\n      initialCoords.startRow,\n      initialCoords.startCol,\n      targetCoords.targetRow,\n      targetCoords.targetCol,\n      grid\n    );\n    let count = 0;\n    const intervalId = setInterval(() => {\n      let row = animations[count].row;\n      let col = animations[count].col;\n      const cell = document.getElementById(`${row} ${col}`);\n      !cell.classList.contains(\"Filled\") &&\n        !cell.classList.contains(\"Target\") &&\n        cell.classList.add(\"Searched\");\n\n      count++;\n\n      if (count >= animations.length) {\n        setAnimationComplete(true);\n        clearInterval(intervalId);\n      }\n    }, 100);\n  };\n\n  const animate = (animations) => {\n    let count = 0;\n\n    const intervalId = setInterval(() => {\n      const node = animations[count];\n\n      node.markSearched();\n      node.isTarget() && node.markShortestPath();\n\n      count++;\n\n      if (count >= animations.length) {\n        setAnimationComplete(true);\n        clearInterval(intervalId);\n      }\n    }, 3);\n  };\n\n  return (\n    <Fragment>\n      <div style={{ margin: \"auto\" }}>\n        <Button onClick={DFS}>Do DFS</Button>\n        <Button onClick={BFS}>Do BFS</Button>\n        <Button onClick={Dijkstra}>Dijkstra</Button>\n        <Button onClick={doRandomMaze}>Random Maze</Button>\n        <Button onClick={doRecursiveDivision}>Recursive Division</Button>\n        <Button onClick={doAStar}>A*</Button>\n        <Button onClick={clear}>Clear</Button>\n      </div>\n      <div\n        onMouseDown={() => {\n          setIsMouseDown(true);\n        }}\n        onMouseUp={() => {\n          setIsMouseDown(false);\n        }}\n        className=\"Board\"\n        style={{\n          gridTemplateRows: `repeat(${ROWS_INIT}, 1fr)`,\n          gridTemplateColumns: `repeat(${COLS_INIT}, 1fr)`,\n        }}\n      >\n        {Grid}\n      </div>\n    </Fragment>\n  );\n};\n\nexport default Board;\n","export const randomMaze = (board) => {\n  for (let row = 0; row < board.length; row++) {\n    for (let col = 0; col < board[row].length; col++) {\n        if (Math.random() <= 0.3) {\n          const node = board[row][col];\n          node.setWall()\n        }\n    }\n  }\n};\n","import React from 'react';\nimport './App.css';\nimport Board from \"./components/Board\"\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <h1 style={{margin: \"auto\"}}>Graphing Algorithm Visualization</h1>\n      <Board/>\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}