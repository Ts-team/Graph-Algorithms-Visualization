{"version":3,"sources":["components/Navigation/NavigationItems/NavigationItem/NavigationItem.module.css","App.module.css","components/Navigation/Toolbar/Toolbar.module.css","components/Cell.js","utility/MazeGenerators/Contour.js","utility/MazeGenerators/RecursiveDivision.js","utility/generateGraph.js","utility/DS/Queue.js","utility/DS/Graph.js","utility/DS/MinHeap.js","utility/constants.js","utility/Node.js","hooks/useNodeGrid.js","components/Navigation/NavigationItems/NavigationItem/NavigationItem.js","components/Navigation/NavigationItems/Dropdown/DropDown.js","components/Navigation/NavigationItems/Subnav/Subnav.js","components/Navigation/NavigationItems/Dropdown/DropItem/DropItem.js","components/Navigation/NavigationItems/NavigationItems.js","components/Navigation/Toolbar/Toolbar.js","components/Board.js","utility/MazeGenerators/Random.js","components/UI/Backdrop/Backdrop.js","components/UI/CustomDialog/CustomDialog.js","App.js","index.js"],"names":["module","exports","Cell","node","onMouseEnter","onMouseDown","onMouseLeave","onMouseUp","classes","useEffect","console","log","setClasses","row","col","push","className","join","id","drawContourWalls","grid","i","length","document","getElementById","classList","add","j","recursiveDivision","a","width","height","prohibitedCells","divide","chooseOrientation","orientation","prohibited","horizontal","whereCol","Math","ceil","random","whereRow","passCol","passRow","drawWall","newwidth","newheight","newwidth2","newheight2","startRow","startCol","cell","contains","isProhibitedCoord","isBorder","remove","updateProhibitedCells","getNeighbors","cellNotInGraph","isWall","neighbors","generateNodeGrid","nodesGrid","graph","Graph","getElementsByClassName","addVertex","generateGraph","startNode","targetNode","currentNode","isStart","isTarget","addEdge","dist","Queue","this","items","element","isEmpty","shift","str","noOfVertices","AdjList","Map","v","set","w","get","get_keys","keys","get_values","conc","startingNode","animations","visited","q","enqueue","getQueueElement","dequeue","get_List","n","neigh","predecessor","withAnimation","DFSUtil","vert","get_neighbours","get_elem","hasSecond","heap","MinHeap","item","finishedAnimating","pop","currentdist","adj","adjacentNode","d","isSecondTarget","dijkstra","f","g","manhattanDistance","print","markSearched2Done","markShortestPath","h","abs","euclideanDistance","sqrt","pow","floor","selector","parentIndex","parentVal","pushedVal","swap","max","t","ret","temp","rightChildIndex","leftChildIndex","lowest","includes","indexOf","arr","GREEDY_BFS","BFS","Node","Infinity","s","isKeyValue","forEach","useNodeGrid","numRows","numCols","newNode","nodeGrid","useRef","current","resetGrid","reset","removeVisuals","paintInDistance","removeClasses","resetDistance","NavigationItem","children","clicked","onClick","Btn","DropDown","title","moreInfo","class","Subnav","DropItem","NavigationItems","setAlgorithm","executeAlgorithm","algorithm","mazeGen","settingSecondTarget","openDialog","clear","setDeleting","alert","cts","toolbar","props","Toolbar","Board","useState","isMouseDown","setIsMouseDown","animating","setIsAnimating","isMovingTarget","setIsMovingTarget","isMovingSecondTarget","setIsMovingSecondTarget","isMovingStart","setIsMovingStart","setSettingSecondTarget","hasSecondTarget","setHasSecondTarget","numTargets","setNumTargets","prevAlgorithm","setPrevAlgorithm","canPlaceWall","setCanPlaceWall","isDeleting","setIsDeleting","onMouseEnterHandler","setAsSecondTarget","setWall","setAsStart","setAsTarget","AStar","util","bestFirstSearch","DFS","handleTargetMove","onMouseDownHandler","onMouseLeaveHandler","removeClass","onMouseUpHandler","Grid","map","rowNum","val","colNum","key","bfs","dfs","Dijkstra","aStar","removeVisualization","doRandomMaze","board","doContour","doRecursiveDivision","animate","count","intervalId","setInterval","markSearched2","clearInterval","type","style","gridTemplateRows","gridTemplateColumns","backdrop","cssClasses","show","CustomDialog","isOpen","handleClose","subtitle","howToPlay","Dialog","fullWidth","maxWidth","open","onclose","aria-labelledby","DialogTitle","DialogContent","DialogContentText","DialogActions","Button","color","App","setIsOpen","handleDialogOpen","customDialog","Paper","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.821bd700.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"NavigationItem\":\"NavigationItem_NavigationItem__2SpXc\",\"Btn\":\"NavigationItem_Btn__3xhRr\",\"navbar\":\"NavigationItem_navbar__2rE4b\",\"NavigationItem-content\":\"NavigationItem_NavigationItem-content__2c_Zw\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"App\":\"App_App__16ZpL\",\"Container\":\"App_Container__10KOh\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"Toolbar\":\"Toolbar_Toolbar__ApScI\",\"dropdown\":\"Toolbar_dropdown__3LTS7\",\"dropbtn\":\"Toolbar_dropbtn__30BvA\"};","import React, { useEffect } from \"react\";\nimport \"./Cell.css\";\n\nconst Cell = ({ node, onMouseEnter, onMouseDown, onMouseLeave, onMouseUp }) => {\n  let classes = [\"Cell\"];\n  let icon = null;\n\n  useEffect(() => {\n    console.log(\"Cell UseEffect\");\n    node.setClasses();\n  }, [node]);\n\n  if (node.row === 10 && node.col === 10) {\n    classes.push(\"Filled\");\n  }\n  if (node.row === 10 && node.col === 30) {\n    classes.push(\"Target\");\n  }\n\n  return (\n    <div\n      className={classes.join(\" \")}\n      id={`${node.row} ${node.col}`}\n      onMouseDown={() => onMouseDown(node)}\n      onMouseEnter={() => onMouseEnter(node)}\n      onMouseLeave={() => onMouseLeave(node)}\n      onMouseUp={() => onMouseUp(node)}\n    >\n      {icon}\n    </div>\n  );\n};\n\nexport default Cell;\n","export const drawContourWalls = (grid) => {\n  for (let i = 0; i < grid.length; i++) {\n    let classes = document.getElementById(`${i} ${0}`).classList;\n    classes.add(\"Wall\");\n    classes = document.getElementById(`${i} ${grid[i].length - 1}`).classList;\n    classes.add(\"Wall\");\n  }\n\n  for (let j = 0; j < grid[0].length; j++) {\n    let classes = document.getElementById(`${0} ${j}`).classList;\n    classes.add(\"Wall\");\n    classes = document.getElementById(`${grid.length - 1} ${j}`).classList;\n    classes.add(\"Wall\");\n  }\n};\n","import { drawContourWalls } from \"./Contour\";\n\nconst HORIZONTAL = \"horizontal\";\nconst VERTICAL = \"vertical\";\n\nexport const recursiveDivision = async (grid) => {\n  drawContourWalls(grid);\n  const width = grid[0].length - 2; // Subtract 2 since we drew a contour\n  const height = grid.length - 2;\n  let prohibitedCells = [];\n  divide(\n    1,\n    1,\n    width,\n    height,\n    chooseOrientation(width, height),\n    prohibitedCells\n  );\n};\n\nconst divide = (col, row, width, height, orientation, prohibited) => {\n  if (width <= 2 || height <= 2) return;\n\n  const horizontal = orientation === HORIZONTAL;\n\n  // Where will the wall be drawn from?\n  let whereCol =\n    col + (horizontal ? 0 : Math.ceil(Math.random() * (width - 2))); // Rand number between the col and width\n\n  let whereRow =\n    row + (horizontal ? Math.ceil(Math.random() * (height - 2)) : 0); // Rand number between the row and height\n\n  // Where will the passage through the wall exist?\n  const passCol =\n    whereCol + (horizontal ? Math.ceil(Math.random() * (width - 1)) : 0); // Rand number between the col and width\n  const passRow =\n    whereRow + (horizontal ? 0 : Math.ceil(Math.random() * (height - 1))); // Rand number between the row and height\n\n  // How long will the wall be?\n  const length = horizontal ? width : height;\n\n  // Draw the walls\n  drawWall(\n    whereRow,\n    whereCol,\n    passRow,\n    passCol,\n    horizontal,\n    length,\n    prohibited\n  );\n\n  let newCol = row;\n  let newRow = col;\n\n  let newwidth = horizontal ? width : whereCol - col;\n  let newheight = horizontal ? whereRow - row : height;\n  divide(\n    newCol,\n    newRow,\n    newwidth,\n    newheight,\n    chooseOrientation(newwidth, newheight),\n    prohibited\n  );\n\n  let newCol2 = horizontal ? col : whereCol + 1;\n  let newRow2 = horizontal ? whereRow + 1 : row;\n\n  let newwidth2 = horizontal ? width : col + width - whereCol - 1;\n  let newheight2 = horizontal ? row + height - whereRow - 1 : height;\n\n  divide(\n    newCol2,\n    newRow2,\n    newwidth2,\n    newheight2,\n    chooseOrientation(newwidth2, newheight2),\n    prohibited\n  );\n};\n\nconst drawWall = (\n  startRow,\n  startCol,\n  passRow,\n  passCol,\n  horizontal,\n  length,\n  prohibited\n) => {\n  for (let i = 0; i < length; i++) {\n    const row = startRow + (horizontal ? 0 : i);\n    const col = startCol + (horizontal ? i : 0);\n\n    const cell = document.getElementById(`${row} ${col}`);\n\n    if (\n      cell &&\n      !cell.classList.contains(\"Target\") &&\n      !cell.classList.contains(\"Filled\") &&\n      !isProhibitedCoord(row, col, prohibited)\n    ) {\n      cell.classList.add(\"Wall\");\n    }\n  }\n\n  const cell = document.getElementById(`${passRow} ${passCol}`);\n  if (cell && !isBorder(passRow, passCol)) {\n    cell.classList.remove(\"Wall\");\n  }\n  updateProhibitedCells(passRow, passCol, horizontal, prohibited);\n};\n\nconst chooseOrientation = (width, height) => {\n  if (width < height) {\n    return HORIZONTAL;\n  }\n  return VERTICAL;\n};\n\nconst updateProhibitedCells = (row, col, horizontal, prohibited) => {\n  if (!horizontal) {\n    prohibited.push([row, col + 1]);\n    prohibited.push([row, col - 1]);\n  } else {\n    prohibited.push([row + 1, col]);\n    prohibited.push([row - 1, col]);\n  }\n};\n\nconst isProhibitedCoord = (row, col, prohibited) => {\n  for (let i = 0; i < prohibited.length; i++) {\n    if (prohibited[i][0] === row && prohibited[i][1] === col) return true;\n  }\n  return false;\n};\n\nconst isBorder = (row, col) => {\n  return row === 0 || row === 19 || col === 0 || col === 49;\n};\n","import { Graph } from \"./index\";\n\nconst getNeighbors = (grid, row, col) => {\n  const cellNotInGraph = (row, col) => {\n    return grid[row][col].isWall();\n  };\n\n  if (cellNotInGraph(row, col)) return [];\n  let neighbors = [];\n\n  if (row > 0 && !cellNotInGraph(row - 1, col)) {\n    // N\n    neighbors.push(grid[row - 1][col]);\n  }\n  if (col > 0 && !cellNotInGraph(row, col - 1)) {\n    // W\n    neighbors.push(grid[row][col - 1]);\n  }\n  if (row < grid.length - 1 && !cellNotInGraph(row + 1, col)) {\n    // S\n    neighbors.push(grid[row + 1][col]);\n  }\n  if (col < grid[row].length - 1 && !cellNotInGraph(row, col + 1)) {\n    // E\n    neighbors.push(grid[row][col + 1]);\n  }\n\n  return neighbors;\n};\n\nexport const calculateNumVertices = () => {\n  const numCells = document.getElementsByClassName(\"Cell\").length;\n  const numWalls = document.getElementsByClassName(\"Wall\").length;\n  return numCells - numWalls;\n};\n\nexport const generateNodeGrid = (grid) => {\n  const nodesGrid = [];\n  const graph = new Graph(calculateNumVertices());\n\n  for (let row in grid) {\n    nodesGrid[row] = [];\n    for (let col in grid[row]) {\n      graph.addVertex(grid[row][col]);\n    }\n  }\n  return graph;\n};\n\nexport const generateGraph = (nodesGrid) => {\n  let startNode = null;\n  let targetNode = null;\n\n  const graph = generateNodeGrid(nodesGrid);\n\n  for (let row = 0; row < nodesGrid.length; row++) {\n    for (let col = 0; col < nodesGrid[row].length; col++) {\n      const currentNode = nodesGrid[row][col];\n\n      if (!currentNode.isWall()) {\n        if (currentNode.isStart()) startNode = currentNode;\n        if(currentNode.isTarget()) targetNode = currentNode;\n        const neighbors = getNeighbors(nodesGrid, row, col);\n\n        for (let i in neighbors) {\n          graph.addEdge(currentNode, neighbors[i]);\n        }\n      }\n    }\n  }\n  startNode.dist = 0;\n  return { graph, startNode, targetNode };\n};\n","// Queue class\nexport class Queue {\n  // Array is used to implement a Queue\n  constructor() {\n    this.items = [];\n  }\n\n  // enqueue(item)\n  enqueue(element) {\n    // adding element to the queue\n    this.items.push(element);\n  }\n\n  // dequeue()\n  dequeue() {\n    // removing element from the queue\n    // returns underflow when called\n    // on empty queue\n    if (this.isEmpty()) return \"Underflow\";\n    return this.items.shift();\n  }\n\n  // front()\n  front() {\n    // returns the Front element of\n    // the queue without removing it.\n    if (this.isEmpty()) return \"No elements in Queue\";\n    return this.items[0];\n  }\n\n  // isEmpty()\n  isEmpty() {\n    // return true if the queue is empty.\n    return this.items.length === 0;\n  }\n\n  // printQueue()\n  printQueue() {\n    var str = \"\";\n    for (var i = 0; i < this.items.length; i++) str += this.items[i] + \" \";\n    return str;\n  }\n}\n","import { Queue } from \"./Queue\";\nimport { MinHeap } from \"../index\";\n\nexport class Graph {\n  constructor(noOfVertices) {\n    this.noOfVertices = noOfVertices;\n    this.AdjList = new Map();\n  }\n\n  addVertex(v) {\n    // initialize the adjacent list with a\n    // null array\n    this.AdjList.set(v, []);\n  }\n\n  addEdge(v, w) {\n    // get the list for vertex v and put the\n    // vertex w denoting edge between v and w\n    this.AdjList.get(v).push(w);\n\n    // Since graph is undirected,\n    // add an edge from w to v also\n    // this.AdjList.get(w).push(v);\n  }\n\n  printGraph() {\n    // get all the vertices\n    var get_keys = this.AdjList.keys();\n\n    // iterate over the vertices\n    for (var i of get_keys) {\n      // great the corresponding adjacency list\n      // for the vertex\n      var get_values = this.AdjList.get(i);\n      var conc = \"\";\n\n      // iterate over the adjacency list\n      // concatenate the values into a string\n      for (var j of get_values) conc += j + \" \";\n\n      // print the vertex and its adjacency list\n      console.log(i + \" -> \" + conc);\n    }\n  }\n\n  // bfs(v)\n  // function to performs BFS\n  bfs(startingNode) {\n    // create a visited array\n    const animations = [];\n\n    var visited = [];\n    for (var i = 0; i < this.noOfVertices; i++) visited[i] = false;\n\n    // Create an object for queue\n    var q = new Queue();\n\n    // add the starting node to the queue\n    visited[startingNode] = true;\n    q.enqueue(startingNode);\n\n    let dist = 1;\n    // loop until queue is element\n    while (!q.isEmpty()) {\n      // get the element from the queue\n      var getQueueElement = q.dequeue();\n\n      // passing the current vertex to callback funtion\n      // console.log(getQueueElement);\n\n      // get the adjacent list for current vertex\n      var get_List = this.AdjList.get(getQueueElement);\n\n      // loop through the list and add the element to the\n      // queue if it is not processed yet\n      for (var n in get_List) {\n        var neigh = get_List[n];\n\n        if (!visited[neigh]) {\n          neigh.predecessor = getQueueElement;\n          neigh.dist = dist;\n          animations.push(neigh);\n          visited[neigh] = true;\n          q.enqueue(neigh);\n        }\n      }\n      dist++;\n    }\n\n    return animations;\n  }\n\n  // dfs(v)\n  // Main DFS method\n  dfs(startingNode, withAnimation) {\n    const animations = [];\n\n    var visited = [];\n    for (var i = 0; i < this.noOfVertices; i++) visited[i] = false;\n\n    this.DFSUtil(startingNode, visited, animations);\n\n    return animations;\n  }\n\n  // Recursive function which process and explore\n  // all the adjacent vertex of the vertex with which it is called\n  DFSUtil(vert, visited, animations) {\n    visited[vert] = true;\n\n    var get_neighbours = this.AdjList.get(vert);\n\n    for (var i in get_neighbours) {\n      var get_elem = get_neighbours[i];\n      if (!visited[get_elem]) {\n        get_elem.predecessor = vert;\n        animations.push(get_elem);\n        this.DFSUtil(get_elem, visited, animations);\n      }\n    }\n  }\n\n  //dijkstra solve graph starting at s\n  dijkstra(startNode, animations, hasSecond) {\n    const heap = new MinHeap((item) => item.dist);\n\n    heap.push(startNode);\n\n    let finishedAnimating = false;\n\n    while (!heap.isEmpty()) {\n      //for each existing solution\n      const currentNode = heap.pop();\n\n      var currentdist = currentNode.dist;\n      var adj = this.AdjList.get(currentNode); // get neighbors\n\n      //for each of its adjacent nodes...\n      for (var a in adj) {\n        const adjacentNode = adj[a];\n\n        //choose nearest node with lowest *total* cost\n        var d = 1 + currentdist;\n\n        if (d < adjacentNode.dist && !heap.contains(adjacentNode)) {\n          if (!finishedAnimating) animations.push(adjacentNode);\n          heap.push(adjacentNode);\n          //reference parent\n          adjacentNode.predecessor = currentNode;\n          adjacentNode.dist = d;\n          if (adjacentNode.isTarget() || adjacentNode.isSecondTarget())\n            if (hasSecond) {\n              this.dijkstra(adjacentNode, animations);\n            } else {\n              finishedAnimating = true;\n            }\n        }\n      }\n    }\n    return animations;\n  }\n\n  aStar(startNode, targetNode, withAnimation) {\n    !withAnimation && console.log(\"NO ANIMATION\");\n    const animations = [];\n\n    const heap = new MinHeap((item) => item.f);\n    startNode.g = 0;\n    this.manhattanDistance(startNode, targetNode);\n\n    heap.push(startNode);\n\n    heap.print();\n\n    while (!heap.isEmpty()) {\n      console.log(heap);\n      const currentNode = heap.pop();\n\n      var currentdist = currentNode.dist;\n      var adj = this.AdjList.get(currentNode); // get neighbors\n      console.log(adj);\n      //for each of its adjacent nodes...\n      for (var a in adj) {\n        const adjacentNode = adj[a];\n\n        //choose nearest node with lowest *total* cost\n        var d = 1 + currentdist;\n\n        if (d < adjacentNode.dist && !heap.contains(adjacentNode)) {\n          if (!withAnimation) {\n            console.log(\"Got here\");\n            adjacentNode.markSearched2Done();\n          }\n          animations.push(adjacentNode);\n          this.manhattanDistance(adjacentNode, targetNode);\n          heap.push(adjacentNode);\n          //reference parent\n          adjacentNode.predecessor = currentNode;\n          adjacentNode.dist = d;\n          if (adjacentNode.isTarget()) {\n            if (!withAnimation) adjacentNode.markShortestPath();\n            return animations;\n          }\n        }\n      }\n    }\n\n    return animations;\n  }\n\n  manhattanDistance(node, targetNode) {\n    const h =\n      Math.abs(node.col - targetNode.col) + Math.abs(node.row - targetNode.row);\n    node.h = h;\n    node.f = node.g + node.h;\n  }\n\n  bestFirstSearch(startNode, targetNode, withAnimation) {\n    const animations = [];\n\n    const heap = new MinHeap((item) => item.f);\n    startNode.g = 0;\n    this.euclideanDistance(startNode, targetNode);\n\n    heap.push(startNode);\n\n    heap.print();\n\n    while (!heap.isEmpty()) {\n      const currentNode = heap.pop();\n\n      var currentdist = currentNode.dist;\n      var adj = this.AdjList.get(currentNode); // get neighbors\n\n      //for each of its adjacent nodes...\n      for (var a in adj) {\n        const adjacentNode = adj[a];\n\n        //choose nearest node with lowest *total* cost\n        var d = 1 + currentdist;\n\n        if (d < adjacentNode.dist && !heap.contains(adjacentNode)) {\n          if (!withAnimation) adjacentNode.markSearched2Done();\n          animations.push(adjacentNode);\n\n          this.euclideanDistance(adjacentNode, targetNode);\n\n          heap.push(adjacentNode);\n\n          //reference parent\n          adjacentNode.predecessor = currentNode;\n          adjacentNode.dist = d;\n          if (adjacentNode.isTarget()) {\n            if (!withAnimation) adjacentNode.markShortestPath();\n            return animations;\n          }\n        }\n      }\n    }\n\n    return animations;\n  }\n\n  euclideanDistance(node, targetNode) {\n    const h = Math.sqrt(\n      Math.pow(node.col - targetNode.col, 2) +\n        Math.pow(node.row - targetNode.row, 2)\n    );\n    node.h = Math.floor(h);\n    node.f = node.g + node.h;\n  }\n}\n","export class MinHeap {\n  constructor(selector) {\n    this.items = [];\n    this.selector = selector;\n  }\n\n  seek() {\n    return this.items[0];\n  }\n\n  push(item) {\n    let i = this.items.length;\n    this.items.push(item);\n\n    let parentIndex = Math.floor((i + 1) / 2 - 1);\n\n    if (parentIndex < 0) parentIndex = 0;\n\n    // console.log(\"ParentIndex\", parentIndex);\n\n    let parentVal = this.selector(this.items[parentIndex]);\n    const pushedVal = this.selector(this.items[i]);\n\n    // console.log(\"ParentVal, parentIndex:\", parentVal, parentIndex);\n    // console.log(\"PushedVal\", pushedVal);\n\n    while (i > 0 && parentVal > pushedVal) {\n      parentIndex = Math.floor((i + 1) / 2 - 1);\n      // console.log(\n      //   \"INSIDE LOOP ParentVal, parentIndex:\",\n      //   parentVal,\n      //   parentIndex\n      // );\n\n      this.swap(i, parentIndex);\n\n      i = parentIndex;\n      // console.log(\n      //   \"New INSIDE LOOP parentIndex:\",\n      //   Math.max(Math.floor((i + 1) / 2 - 1), 0)\n      // );\n\n      parentVal = this.selector(\n        this.items[Math.max(Math.floor((i + 1) / 2 - 1), 0)]\n      );\n    }\n\n    // this.print();\n  }\n\n  swap(i, j) {\n    let t = this.items[i];\n    this.items[i] = this.items[j];\n    this.items[j] = t;\n  }\n\n  pop() {\n    // console.log(\"Items before pop:\", this.items);\n    if (this.items.length <= 1) return this.items.pop(); //If it is the last element pop it\n    const ret = this.items[0]; // What we will return\n    let temp = this.items.pop();\n    this.items[0] = temp; // Place last element in array at front\n\n    // console.log(\"Items after pop:\", this.items); // Good till here\n    let i = 0; // We adjust heap from top to down\n\n    while (true) {\n      let rightChildIndex = (i + 1) * 2;\n      let leftChildIndex = (i + 1) * 2 - 1;\n\n      // console.log(\"rightIndex\", rightChildIndex);\n      // console.log(\"rightValue\", this.items[rightChildIndex]);\n      // console.log(\"leftIndex\", leftChildIndex);\n      // console.log(\"leftValue\", this.items[leftChildIndex]);\n      let lowest = rightChildIndex;\n\n      if (\n        leftChildIndex >= this.items.length &&\n        rightChildIndex >= this.items.length\n      )\n        break;\n      if (leftChildIndex >= this.items.length) lowest = rightChildIndex;\n      if (rightChildIndex >= this.items.length) lowest = leftChildIndex;\n\n      if (\n        !(leftChildIndex >= this.items.length) &&\n        !(rightChildIndex >= this.items.length)\n      ) {\n        lowest =\n          this.selector(this.items[rightChildIndex]) <\n          this.selector(this.items[leftChildIndex])\n            ? rightChildIndex\n            : leftChildIndex;\n      } // Find the smallest child\n\n      // If the parent is greater than the smallest child: swap\n      if (this.selector(this.items[i]) > this.selector(this.items[lowest])) {\n        this.swap(i, lowest);\n        i = lowest;\n      } else break; // We have finished setting up the heap\n    }\n\n    // Return topmost element\n    return ret;\n  }\n\n  contains(item) {\n    return this.items.includes(item);\n  }\n\n  isEmpty() {\n    return this.items.length === 0;\n  }\n\n  delete(item) {\n    let i = this.items.indexOf(item);\n    // heapify\n    this.items[i] = this.items.pop();\n    while (true) {\n      let lowest =\n        this.selector(this.items[(i + 1) * 2]) <\n        this.selector(this.items[(i + 1) * 2 - 1])\n          ? (i + 1) * 2\n          : (i + 1) * 2 - 1;\n      if (this.selector(this.items[i]) > this.selector(this.items[lowest])) {\n        let t = this.items[i];\n        this.items[i] = this.items[lowest];\n        this.items[lowest] = t;\n        i = lowest;\n      } else break;\n    }\n  }\n\n  print() {\n    for (let i = 0; i < this.items.length; i++) {\n      console.log(this.items[i]);\n    }\n  }\n\n  heapify(arr) {\n    for (let i = 0; i < arr.length; i++) {\n      this.push(arr[i]);\n    }\n  }\n}\n\n// const heap = new MinHeap((x) => x.dist);\n// heap.heapify([6, 3, 6, 9, 43, 0, 8, 0, 8]);\n// console.log(heap);\n// console.log(heap.isEmpty());\n\n// heap.heapify([1, 2, 7, 4, 8, 0, 4, 2, 7, 3]);\n\n// heap.heapify([\n//   { dist: 1 },\n//   { dist: 2 },\n//   { dist: 7 },\n//   { dist: 4 },\n//   { dist: 8 },\n//   { dist: 0 },\n//   { dist: 4 },\n//   { dist: 2 },\n//   { dist: 7 },\n//   { dist: 3 },\n// ]);\n\n// heap.heapify([\n//   { dist: 1 },\n//   { dist: 2 },\n//   { dist: 7 },\n//   { dist: 4 },\n//   { dist: 8 },\n//   { dist: 0 },\n//   { dist: 4 },\n//   { dist: 2 },\n//   { dist: 7 },\n//   { dist: 3 },\n//   { dist: 23 },\n//   { dist: 200 },\n//   { dist: -1 },\n// ]);\n\n// heap.print();\n// // const a = heap.pop()\n// // heap.pop()\n// // heap.pop()\n\n// console.log(heap.items);\n\n// while (!heap.isEmpty()) {\n//   // console.log(\"Length\", heap.items.length);\n//   const a = heap.pop();\n//   console.log(\"Value:\", a);\n//   // console.log(\"Length\", heap.items.length);\n// }\n","export const DIJKSTRA = \"Dijkstra\"\nexport const ASTAR = \"A*\"\nexport const GREEDY_BFS = \"Greedy Best First Search\"\nexport const BFS = \"Breadth First Search\"\nexport const DFS = \"Depth First Search\"\n\nexport const RAND_MAZE = \"Random Maze\"\nexport const RECURSIVE_DIVISON = \"Recursive Division\"\nexport const DRAW_COUNTOUR = \"Contour Walls\"\n","export default class Node {\n  constructor(row, col) {\n    this.row = row;\n    this.col = col;\n    this.predecessor = null;\n    this.dist = Infinity;\n    this.g = 1;\n    this.h = null;\n    this.f = null;\n  }\n\n  removeClass(s) {\n    this.classes.remove(s);\n  }\n\n  setClasses() {\n    this.cell = document.getElementById(`${this.row} ${this.col}`);\n    this.classes = this.cell.classList;\n  }\n\n  toString() {\n    return \"(\" + this.row + \" \" + this.col + \")\";\n  }\n\n  setWall() {\n    if (this.isKeyValue()) return;\n    this.classes.add(\"Wall\");\n  }\n\n  setAsTarget() {\n    this.classes.add(\"Target\");\n    this.markShortestPath();\n  }\n\n  setAsStart() {\n    this.classes.remove(\"Wall\");\n    this.classes.add(\"Filled\");\n  }\n\n  setAsSecondTarget() {\n    this.classes.remove(\"Wall\");\n    this.classes.add(\"SecondaryTarget\");\n  }\n\n  markSearched() {\n    if (this.isTarget()) return;\n    this.classes.add(\"Searched\");\n  }\n\n  markSearched2() {\n    if (this.isTarget()) return;\n    this.classes.add(\"Searched2\");\n  }\n\n  markSearched2Done() {\n    if (this.isTarget() || this.isStart()) return;\n    this.classes.add(\"Searched2Done\");\n  }\n\n  removeVisuals() {\n    this.remove([\"ShortestPath\", \"Searched\", \"Searched2\", \"Searched2Done\"])\n    this.predecessor = null;\n    this.dist = Infinity;\n  }\n\n  removeClasses() {\n    this.classes.forEach(\n      (item) => item !== \"Cell\" && item !== \"Wall\" && this.classes.remove(item)\n    );\n  }\n\n  reset() {\n    this.remove([\"ShortestPath\", \"Wall\", \"Searched\"]);\n    this.remove([\"Searched2\", \"SecondaryTarget\", \"Searched2Done\"]);\n    this.predecessor = null;\n    this.dist = Infinity;\n  }\n\n  isTarget() {\n    return this.classes.contains(\"Target\");\n  }\n\n  isStart() {\n    return this.classes.contains(\"Filled\");\n  }\n\n  isSecondTarget() {\n    return this.classes.contains(\"SecondaryTarget\");\n  }\n\n  isKeyValue() {\n    return this.isTarget() || this.isStart() || this.isSecondTarget();\n  }\n\n  isWall() {\n    return this.classes.contains(\"Wall\");\n  }\n\n  isPartOfGraph() {\n    return !this.isWall();\n  }\n\n  markShortestPath() {\n    if (!this.isTarget() && !this.isStart()) {\n      this.remove([\"Searched\", \"Searched2\", \"Searched2Done\"]);\n      this.classes.add(\"ShortestPath\");\n    }\n    if (this.predecessor != null) {\n      this.predecessor.markShortestPath();\n    }\n  }\n\n  remove(classes) {\n    for (let i in classes) this.classes.remove(classes[i]);\n  }\n}\n","import { useRef } from \"react\";\nimport Node from \"../utility/Node\";\n\nconst generateNodeGrid = (numRows, numCols) => {\n  const nodesGrid = [];\n\n  for (let row = 0; row < numRows; row++) {\n    nodesGrid[row] = [];\n    for (let col = 0; col < numCols; col++) {\n      const newNode = new Node(row, col);\n      nodesGrid[row][col] = newNode;\n    }\n  }\n\n  return nodesGrid;\n};\n\nconst useNodeGrid = () => {\n  const nodesGrid = generateNodeGrid(20, 50);\n  const nodeGridRef = useRef(nodesGrid);\n  const nodeGrid = nodeGridRef.current;\n\n  const resetGrid = () => {\n    for (let row in nodeGrid) {\n      for (let col in nodeGrid[row]) {\n        nodeGrid[row][col].reset();\n      }\n    }\n  };\n\n  const removeVisuals = () => {\n    for (let row in nodeGrid) {\n      for (let col in nodeGrid[row]) {\n        nodeGrid[row][col].removeVisuals();\n      }\n    }\n  };\n\n  const paintInDistance = (dist) => {\n    if (dist === Infinity) return;\n    for (let row in nodeGrid) {\n      for (let col in nodeGrid[row]) {\n        if (nodeGrid[row][col].dist <= dist) {\n          nodeGrid[row][col].markSearched2Done();\n        } else {\n          nodeGrid[row][col].removeClasses();\n        }\n      }\n    }\n  };\n\n  const resetDistance = () => {\n    for (let row in nodeGrid) {\n      for (let col in nodeGrid[row]) {\n        nodeGrid[row][col].dist = Infinity;\n        if (!nodeGrid[row][col].isKeyValue()) {\n          nodeGrid[row][col].removeClasses();\n        }\n      }\n    }\n  };\n\n  return { nodeGrid, resetGrid, removeVisuals, paintInDistance, resetDistance };\n};\n\nexport default useNodeGrid;\n","import React from \"react\";\nimport classes from \"./NavigationItem.module.css\";\n\nconst NavigationItem = ({ children, clicked }) => (\n  <div className={classes.NavigationItem}>\n    <button onClick={clicked} className={classes.Btn}>\n      {children}\n    </button>\n  </div>\n);\nexport default NavigationItem;\n","import React from \"react\";\nimport \"./DropDown.css\";\n\nconst DropDown = ({ children, clicked, moreInfo, title }) => {\n  return (\n    <div class=\"dropdown\">\n      <button class=\"dropbtn\">\n        {title}\n      </button>\n      <div class=\"dropdown-content\">\n        {children}\n      </div>\n    </div>\n  );\n};\n\nexport default DropDown;\n","import React from \"react\";\nimport \"./Subnav.css\";\n\nconst Subnav = ({ children, title }) => {\n  return (\n    <div class=\"subnav\">\n      <button class=\"subnavbtn\">{title}</button>\n      <div class=\"subnav-content\">{children}</div>\n    </div>\n  );\n};\n\nexport default Subnav;\n","import React from \"react\";\n\nconst DropItem = ({children, clicked}) => {\nreturn <p onClick={clicked}>{children}</p>;\n};\n\nexport default DropItem;\n","import React from \"react\";\nimport NavigationItem from \"./NavigationItem/NavigationItem\";\nimport * as cts from \"../../../utility\";\nimport DropDown from \"./Dropdown/DropDown\";\nimport Subnav from \"./Subnav/Subnav\";\nimport DropItem from \"./Dropdown/DropItem/DropItem\";\n\nconst NavigationItems = ({\n  setAlgorithm,\n  reset,\n  executeAlgorithm,\n  algorithm,\n  mazeGen,\n  settingSecondTarget,\n  openDialog,\n  clear,\n  setDeleting\n}) => (\n  <>\n    <NavigationItem clicked={openDialog}>GRAPH ALGORITHMS</NavigationItem>\n    <Subnav title=\"Algorithms\">\n      <DropDown title={cts.DIJKSTRA}>\n        <DropItem clicked={() => setAlgorithm(cts.DIJKSTRA)}>Select</DropItem>\n        <DropItem clicked={() => alert(cts.DIJKSTRA)}>Learn More</DropItem>\n      </DropDown>\n      <DropDown\n        clicked={() => setAlgorithm(cts.ASTAR)}\n        moreInfo={() => alert(cts.ASTAR)}\n        title={cts.ASTAR}\n      >\n        <DropItem clicked={() => setAlgorithm(cts.ASTAR)}>Select</DropItem>\n        <DropItem clicked={() => alert(cts.ASTAR)}>Learn More</DropItem>\n      </DropDown>\n      <DropDown\n        clicked={() => setAlgorithm(cts.GREEDY_BFS)}\n        moreInfo={() => alert(cts.GREEDY_BFS)}\n        title={cts.GREEDY_BFS}\n      >\n        <DropItem clicked={() => setAlgorithm(cts.GREEDY_BFS)}>Select</DropItem>\n        <DropItem clicked={() => alert(cts.GREEDY_BFS)}>Learn More</DropItem>\n      </DropDown>\n      <DropDown title={cts.BFS}>\n        <DropItem clicked={() => setAlgorithm(cts.BFS)}>Select</DropItem>\n        <DropItem clicked={() => alert(cts.BFS)}>Learn More</DropItem>\n      </DropDown>\n      <DropDown title={cts.DFS}>\n        <DropItem clicked={() => setAlgorithm(cts.DFS)}>Select</DropItem>\n        <DropItem clicked={() => alert(cts.DFS)}>Learn More</DropItem>\n      </DropDown>\n    </Subnav>\n    <Subnav title=\"Maze Generators\">\n      <DropDown\n        title={cts.RAND_MAZE}\n        clicked={() => mazeGen(cts.RAND_MAZE)}\n        moreInfo={() => alert(cts.DIJKSTRA)}\n      >\n        <DropItem clicked={() => mazeGen(cts.RAND_MAZE)}>Generate</DropItem>\n        <DropItem clicked={() => alert(cts.RECURSIVE_DIVISON)}>\n          Learn More\n        </DropItem>\n      </DropDown>\n      <DropDown title={cts.RECURSIVE_DIVISON}>\n        <DropItem clicked={() => mazeGen(cts.RECURSIVE_DIVISON)}>\n          Generate\n        </DropItem>\n        <DropItem clicked={() => alert(cts.RECURSIVE_DIVISON)}>\n          Learn More\n        </DropItem>\n      </DropDown>\n      <DropDown title={cts.DRAW_COUNTOUR}>\n        <DropItem clicked={() => mazeGen(cts.DRAW_COUNTOUR)}>\n          Generate\n        </DropItem>\n        <DropItem clicked={() => alert(cts.DRAW_COUNTOUR)}>\n          Learn More\n        </DropItem>\n      </DropDown>\n    </Subnav>\n    <Subnav title=\"Draw\">\n    <DropDown title=\"Options\">\n        <DropItem clicked={() => setDeleting(true)}>\n          Delete Wall\n        </DropItem>\n        <DropItem clicked={() => setDeleting(false)}>\n          Draw Wall\n        </DropItem>\n      </DropDown>\n    </Subnav>\n   \n    <NavigationItem clicked={() => settingSecondTarget(true)}>Add Second Target</NavigationItem>\n    <NavigationItem clicked={reset}>Reset</NavigationItem>\n    <NavigationItem clicked={clear}>Clear Visualization</NavigationItem>\n    <NavigationItem clicked={executeAlgorithm}>\n      Visualize {algorithm}!\n    </NavigationItem>\n  </>\n);\nexport default NavigationItems;\n","import React from \"react\";\nimport classes from \"./Toolbar.module.css\";\nimport NavigationItems from \"../NavigationItems/NavigationItems\";\n\nconst toolbar = (props) => {\n  return (\n    <header className={classes.Toolbar}>\n        <NavigationItems {...props} />\n    </header>\n  );\n};\nexport default toolbar;\n","import React, { useState } from \"react\";\nimport Cell from \"./Cell\";\nimport * as util from \"../utility/index\";\nimport \"./Board.css\";\nimport useNodeGrid from \"../hooks/useNodeGrid\";\nimport Navbar from \"./Navigation/Toolbar/Toolbar\";\n\nconst ROWS_INIT = 20;\nconst COLS_INIT = 50;\n\nconst Board = ({ openDialog }) => {\n  const [algorithm, setAlgorithm] = useState(util.DIJKSTRA);\n  const {\n    nodeGrid,\n    resetGrid,\n    removeVisuals,\n    paintInDistance,\n    resetDistance,\n  } = useNodeGrid();\n  const [isMouseDown, setIsMouseDown] = useState(false);\n  const [animating, setIsAnimating] = useState(true);\n  const [isMovingTarget, setIsMovingTarget] = useState(false);\n  const [isMovingSecondTarget, setIsMovingSecondTarget] = useState(false);\n  const [isMovingStart, setIsMovingStart] = useState(false);\n  const [settingSecondTarget, setSettingSecondTarget] = useState(false);\n  const [hasSecondTarget, setHasSecondTarget] = useState(false);\n  const [numTargets, setNumTargets] = useState(1);\n  const [prevAlgorithm, setPrevAlgorithm] = useState(util.DIJKSTRA);\n  const [canPlaceWall, setCanPlaceWall] = useState(true);\n  const [isDeleting, setIsDeleting] = useState(false);\n\n  console.log(isDeleting);\n\n  const handleTargetMove = (node) => {\n    node.setAsTarget();\n    switch (prevAlgorithm) {\n      case util.DIJKSTRA:\n        paintInDistance(node.dist);\n        node.markShortestPath();\n        break;\n      case util.ASTAR:\n        resetDistance();\n        AStar(false);\n        break;\n      case util.GREEDY_BFS:\n        resetDistance();\n        bestFirstSearch(false);\n        break;\n      case util.BFS:\n        paintInDistance(node.dist);\n        node.markShortestPath();\n        break;\n      case util.DFS:\n        resetDistance();\n        DFS(false);\n        node.markShortestPath();\n        break;\n      default:\n    }\n  };\n\n  const onMouseEnterHandler = (node) => {\n    if (!animating) return;\n    if (settingSecondTarget) {\n      node.setAsSecondTarget();\n    }\n    if (\n      isMouseDown &&\n      !isMovingStart &&\n      !isMovingTarget &&\n      !isMovingSecondTarget\n    ) {\n      if (canPlaceWall) node.setWall();\n    }\n    if (isMouseDown && isMovingStart && !node.isTarget()) node.setAsStart();\n    if (isMouseDown && isMovingTarget && !node.isStart()) {\n      handleTargetMove(node);\n    }\n    if (isMouseDown && isMovingSecondTarget) node.setAsSecondTarget();\n  };\n\n  const onMouseDownHandler = (node) => {\n    if (!animating) return;\n    if (isDeleting) return node.remove([\"Wall\"]);\n    setIsMouseDown(true);\n    if (settingSecondTarget) {\n      let num = numTargets;\n      setNumTargets(num + 1);\n      setHasSecondTarget(true);\n      return setSettingSecondTarget(false);\n    }\n    if (!node.isKeyValue() && canPlaceWall) return node.setWall();\n    if (node.isStart() && canPlaceWall) return setIsMovingStart(true);\n    if (node.isTarget()) return setIsMovingTarget(true);\n    if (node.isSecondTarget()) return setIsMovingSecondTarget(true);\n  };\n\n  const onMouseLeaveHandler = (node) => {\n    if (!animating) return;\n    if (\n      isMovingStart ||\n      isMovingTarget ||\n      settingSecondTarget ||\n      isMovingSecondTarget\n    ) {\n      if (isMovingStart) node.removeClass(\"Filled\");\n      if (isMovingTarget) node.removeClass(\"Target\");\n    }\n  };\n\n  const onMouseUpHandler = () => {\n    if (!animating) return;\n    setIsMouseDown(false);\n    setIsMovingStart(false);\n    setIsMovingTarget(false);\n    setIsMovingSecondTarget(false);\n  };\n\n  let Grid = nodeGrid.map((row, rowNum) => {\n    return row.map((val, colNum) => {\n      return (\n        <Cell\n          key={val}\n          node={nodeGrid[rowNum][colNum]}\n          onMouseEnter={onMouseEnterHandler}\n          onMouseDown={onMouseDownHandler}\n          onMouseUp={onMouseUpHandler}\n          onMouseLeave={onMouseLeaveHandler}\n        />\n      );\n    });\n  });\n\n  const executeAlgorithm = (type) => {\n    removeVisualization();\n    if (!animating) return;\n    setIsAnimating(false);\n    setPrevAlgorithm(algorithm);\n    setCanPlaceWall(false);\n\n    let animations = [];\n    switch (algorithm) {\n      case util.BFS:\n        animations = BFS();\n        break;\n      case util.DFS:\n        animations = DFS(true);\n        break;\n      case util.ASTAR:\n        animations = AStar(true);\n        break;\n      case util.DIJKSTRA:\n        animations = Dijkstra();\n        break;\n      case util.GREEDY_BFS:\n        animations = bestFirstSearch(true);\n        break;\n      default:\n        animations = BFS();\n        break;\n    }\n    animate(animations);\n  };\n\n  const BFS = () => {\n    const { startNode, graph } = util.generateGraph(nodeGrid);\n    const animations = graph.bfs(startNode);\n    return animations;\n  };\n\n  const DFS = (withAnimation) => {\n    const { startNode, graph } = util.generateGraph(nodeGrid);\n    const animations = graph.dfs(startNode, withAnimation);\n    return animations;\n  };\n\n  const Dijkstra = () => {\n    const { startNode, graph } = util.generateGraph(nodeGrid);\n    const animations = [];\n    graph.dijkstra(startNode, animations, hasSecondTarget);\n    return animations;\n  };\n\n  const AStar = (withAnimation) => {\n    const { startNode, graph, targetNode } = util.generateGraph(nodeGrid);\n    const animations = graph.aStar(startNode, targetNode, withAnimation);\n    return animations;\n  };\n\n  const bestFirstSearch = (withAnimation) => {\n    const { startNode, graph, targetNode } = util.generateGraph(nodeGrid);\n    const animations = graph.bestFirstSearch(\n      startNode,\n      targetNode,\n      withAnimation\n    );\n    return animations;\n  };\n\n  const clear = () => {\n    if (!animating) return;\n    setCanPlaceWall(true);\n    setHasSecondTarget(false);\n    setPrevAlgorithm(null);\n    resetGrid();\n  };\n\n  const removeVisualization = () => {\n    if (!animating) return;\n    setCanPlaceWall(true);\n    setPrevAlgorithm(null);\n    removeVisuals();\n  };\n\n  const generateMaze = (type) => {\n    switch (type) {\n      case util.RECURSIVE_DIVISON:\n        doRecursiveDivision();\n        break;\n      case util.DRAW_COUNTOUR:\n        doContour();\n        break;\n      default:\n        doRandomMaze();\n        break;\n    }\n  };\n\n  const doRandomMaze = () => {\n    if (!animating) return;\n    clear();\n    util.randomMaze(nodeGrid);\n  };\n\n  const doContour = () => {\n    if (!animating) return;\n    clear();\n    util.drawContourWalls(nodeGrid);\n  };\n\n  const doRecursiveDivision = () => {\n    if (!animating) return;\n    clear();\n    util.recursiveDivision(nodeGrid);\n  };\n\n  const animate = (animations) => {\n    if (animations.length <= 0) {\n      setIsAnimating(true);\n      return;\n    }\n    let count = 0;\n    let targetNum = 1;\n\n    const intervalId = setInterval(() => {\n      const node = animations[count];\n\n      targetNum % 2 === 0 ? node.markSearched() : node.markSearched2();\n\n      (node.isTarget() || node.isSecondTarget()) && node.markShortestPath();\n\n      count++;\n\n      if (count >= animations.length) {\n        setIsAnimating(true);\n        clearInterval(intervalId);\n      }\n    }, 10);\n  };\n\n  return (\n    <div className=\"MainContainer\">\n      <Navbar\n        setDeleting={setIsDeleting}\n        openDialog={openDialog}\n        setAlgorithm={setAlgorithm}\n        reset={clear}\n        algorithm={algorithm}\n        executeAlgorithm={executeAlgorithm}\n        clear={removeVisualization}\n        mazeGen={generateMaze}\n        settingSecondTarget={setSettingSecondTarget}\n      />\n      <br />\n      <div\n        className=\"Board\"\n        style={{\n          gridTemplateRows: `repeat(${ROWS_INIT}, 1fr)`,\n          gridTemplateColumns: `repeat(${COLS_INIT}, 1fr)`,\n        }}\n      >\n        {Grid}\n      </div>\n    </div>\n  );\n};\n\nexport default Board;\n","export const randomMaze = (board) => {\n  for (let row = 0; row < board.length; row++) {\n    for (let col = 0; col < board[row].length; col++) {\n        if (Math.random() <= 0.3) {\n          const node = board[row][col];\n          node.setWall()\n        }\n    }\n  }\n};\n","import React from \"react\";\nimport \"./Backdrop.css\";\n\nconst backdrop = (props) => {\n  const cssClasses = [\n    \"Backdrop\",\n    props.show ? \"BackdropOpen\" : \"BackdropClosed\",\n  ];\n  return <div className={cssClasses.join(\" \")}></div>;\n};\n\nexport default backdrop;\n","import React from \"react\";\nimport {\n  Button,\n  Dialog,\n  DialogActions,\n  DialogContent,\n  DialogContentText,\n  DialogTitle,\n} from \"@material-ui/core\";\nimport PropTypes from \"prop-types\";\nimport Backdrop from \"../Backdrop/Backdrop\";\n\nexport const CustomDialog = ({\n  isOpen,\n  handleClose,\n  title,\n  subtitle,\n  children,\n  howToPlay,\n}) => {\n  return (\n    <>\n      <Dialog\n        fullWidth\n        maxWidth=\"md\"\n        open={isOpen}\n        onclose={handleClose}\n        aria-labelledby=\"max-width-dialog-title\"\n      >\n        <DialogTitle id=\"max-width-dialog-title\">{title}</DialogTitle>\n        <DialogContent>\n          <DialogContentText>{subtitle}</DialogContentText>\n          {children}\n        </DialogContent>\n        <DialogActions>\n          <Button onClick={handleClose} color=\"secondary\">\n            Close\n          </Button>\n        </DialogActions>\n      </Dialog>\n      <Backdrop show={isOpen} />\n    </>\n  );\n};\n\nCustomDialog.propTypes = {\n  isOpen: PropTypes.bool.isRequired,\n  handleClose: PropTypes.func.isRequired,\n  title: PropTypes.string.isRequired,\n  subtitle: PropTypes.string,\n  children: PropTypes.element.isRequired,\n};\n","import React, { useState, useEffect } from \"react\";\nimport Board from \"./components/Board\";\nimport { CustomDialog } from \"./components/UI/CustomDialog/CustomDialog\";\nimport Paper from \"@material-ui/core/Paper\";\nimport classes from \"./App.module.css\";\n\nfunction App() {\n  const [isOpen, setIsOpen] = useState(true);\n  useEffect(() => {\n    handleDialogOpen();\n  }, []);\n\n  const handleDialogOpen = () => {\n    setIsOpen(true);\n  };\n\n  const handleDialogClose = () => {\n    setIsOpen(false);\n  };\n  return (\n    <div className={classes.App}>\n      <Board openDialog={handleDialogOpen}/>\n      <CustomDialog\n        isOpen={isOpen}\n        handleClose={handleDialogClose}\n        className={classes.customDialog}\n      >\n        <Paper>\n          <h1>Welcome to The Graph Algorithms Visualizer!</h1>\n          <br />\n          <h4>\n            This Project Helps CS Enthusiasts visualize popular graph\n            traversal/pathfinding algorithms. To get Started, click on an\n            algorithm located on the header and press Visualize!.\n          </h4>\n          <p>For a better Experience, Use use browser to full width</p>\n        </Paper>\n      </CustomDialog>\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}